<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>Week 5 HW on Matteo Bianchi personal site and blog</title>
    <link>https://www.matteobianchi.eu/statistics-posts/week_5/</link>
    <description>Recent content in Week 5 HW on Matteo Bianchi personal site and blog</description>
    <image>
      <title>Week 5 HW on Matteo Bianchi personal site and blog</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_5/</link>
      <url>https://source.unsplash.com/collection/983219/2000x1322</url>
    </image>
    <ttl>1440</ttl>
    <generator>After Dark 9.2.3 (Hugo 0.80.0)</generator>
    <language>en-US</language>
    <lastBuildDate>Fri, 04 Feb 2022 15:08:14 UT</lastBuildDate>
    <atom:link href="https://www.matteobianchi.eu/statistics-posts/week_5/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>5_RA</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_5/5ra/</link>
      <pubDate>Sat, 23 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_5/5ra/</guid>
      <description>5_RA assignament Request Do a web research about the various methods to generate, from a Uniform([0,1)), all the most important random variables (discrete and continuous). Collect all source code you think might be useful code of such algorithms (keep credits and attributions wherever applicable), as they will be useful for our next simulations.
Generate a bernulli distribution Various freamework include this distribution (for example Accord), and also some standard libraries like MathNet:</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[5_RA assignament Request Do a web research about the various methods to generate, from a Uniform([0,1)), all the most important random variables (discrete and continuous). Collect all source code you think might be useful code of such algorithms (keep credits and attributions wherever applicable), as they will be useful for our next simulations.
Generate a bernulli distribution Various freamework include this distribution (for example Accord), and also some standard libraries like MathNet:
public void GenerateChange(Point reference) { Bernoulli rBernoulli = new Bernoulli(0.5); double percentage = (rBernoulli.Sample() &amp;gt; 0.5 ? -1 : 1) * Simulation.Default.Data_Change_Maximum_Percentage * random.NextDouble(); GenerateChange(reference, percentage); } Or in pure c:
#include &amp;lt;iostream&amp;gt; 2: #include &amp;lt;iomanip&amp;gt; 3: #include &amp;lt;chrono&amp;gt; 4: #include &amp;#34;ZZ.h&amp;#34; 5: using namespace std; 6: 7: typedef std::pair&amp;lt;ZZ_t*, ZZ_t*&amp;gt; QQ_t; 8: 9: // Computes the first n even absolute Bernoulli numbers  10: // B[0], B[2], B[4], ..., B[2*n - 2] for n &amp;gt;= 1.  11: QQ_t bernoulliT(int n) 12: { 13: /* assert(n &amp;gt; 0); */ 14: 15: ZZ_t g, num, den = ZZ_t(1), p = ZZ_t(1); 16: long k, j; 17: 18: ZZ_t* T = new ZZ_t[n]; 19: ZZ_t* N = new ZZ_t[n]; 20: ZZ_t* D = new ZZ_t[n]; 21: 22: N[0] = ZZ_t(1); 23: D[0] = ZZ_t(1); 24: 25: if (n == 1) return QQ_t(N, D); 26: 27: T[1] = ZZ_t(1); 28: 29: for (k = 2; k &amp;lt; n; k&#43;&#43;) 30: { 31: T[k] = T[k - 1] * (k - 1); 32: } 33: 34: for (k = 2; k &amp;lt; n; k&#43;&#43;) 35: { 36: for (j = k; j &amp;lt; n; j&#43;&#43;) 37: { 38: T[j] = T[j - 1] * (j - k) &#43; T[j] * (j - k &#43; 2); 39: } 40: } 41: 42: for (k = 1; k &amp;lt; n; k&#43;&#43;) 43: { 44: p *= 4; 45: den = p * (p - 1); 46: num = T[k] * (k &#43; k); 47: g = gcd(num, den); 48: N[k] = num / g; 49: D[k] = den / g; 50: } 51: 52: delete[] T; 53: return QQ_t(N, D); 54: } 55: 56: // Computes the first n even absolute Bernoulli numbers  57: // B[0], B[2], B[4], ..., B[2*n - 2] for n &amp;gt;= 1.  58: QQ_t bernoulliS(int n) 59: { 60: /* assert(n &amp;gt; 0); */ 61: 62: ZZ_t g, den = ZZ_t(1), p = ZZ_t(1); 63: long h = 0, k, i, j = 1, tog = 1; 64: 65: ZZ_t* T = new ZZ_t[n]; 66: ZZ_t* N = new ZZ_t[n]; 67: ZZ_t* D = new ZZ_t[n]; 68: 69: N[0] = ZZ_t(1); 70: D[0] = ZZ_t(1); 71: 72: if (n == 1) return QQ_t(N, D); 73: 74: T[1] = ZZ_t(1); 75: 76: for (i = 3; i &amp;lt;= 2 * n; i&#43;&#43;) 77: { 78: if (tog) 79: { 80: p *= 4; 81: den = (p - 1) * 2; 82: 83: for (k = h&#43;&#43;; k &amp;gt; 0; k--) 84: T[k] &#43;= T[k &#43; 1]; 85: } 86: else 87: { 88: for (k = 1; k &amp;lt;= h; k&#43;&#43;) 89: T[k] &#43;= T[k - 1]; 90: 91: g = gcd(T[h], den); 92: N[j] = T[h] / g; 93: D[j&#43;&#43;] = den / g; 94: } 95: tog = 1 - tog; 96: } 97: 98: delete [] T; 99: return QQ_t(N, D); 100: } 101: 102: int main() 103: { 104: int n = 500, i, rep; 105: pair&amp;lt;ZZ_t*, ZZ_t*&amp;gt; B; 106: 107: chrono::time_point&amp;lt;chrono::system_clock&amp;gt; start, end; 108: start = chrono::system_clock::now(); 109: 110: for (rep = 0; rep &amp;lt; 10; rep&#43;&#43;) 111: { 112: B = bernoulliT(n); 113: } 114: 115: end = chrono::system_clock::now(); 116: chrono::duration&amp;lt;double&amp;gt; elapsed_seconds = end - start; 117: 118: cout &amp;lt;&amp;lt; &amp;#34;elapsed time: &amp;#34; &amp;lt;&amp;lt; elapsed_seconds.count() / rep 119: &amp;lt;&amp;lt; &amp;#34; seconds.&amp;#34; &amp;lt;&amp;lt; endl; 120: 121: ZZ_t* numer = B.first; 122: ZZ_t* denom = B.second; 123: 124: if (n &amp;lt; 100) 125: { 126: for (i = 0; i &amp;lt; n; i&#43;&#43;) 127: { 128: cout &amp;lt;&amp;lt; &amp;#34;B[&amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34;] = &amp;#34; 129: &amp;lt;&amp;lt; numer[i] &amp;lt;&amp;lt; &amp;#34;/&amp;#34; 130: &amp;lt;&amp;lt; denom[i] &amp;lt;&amp;lt; endl; 131: } 132: } 133: 134: delete [] numer; 135: delete [] denom; 136: 137: cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;#34;Done!&amp;#34; &amp;lt;&amp;lt; endl; 138: cin.get(); 139: 140: return 0; 141: } C# 1: using ZZ_t = System.Numerics.BigInteger; 2: using QQ_t = System.Tuple&amp;lt;System.Numerics.BigInteger, System.Numerics.BigInteger&amp;gt;; 3: 4: namespace WilliamHartChallenge 5: { 6: class Bernoulli 7: { 8: // Computes the first n even _absolute_ Bernoulli numbers.  9: // B[0], B[2], B[4], ..., B[2*n - 2] for n &amp;gt;= 1.  10: static QQ_t[] bernoulliT(int n) 11: { 12: // System.Diagnostics.Debug.Assert(n &amp;gt; 0);  13: 14: ZZ_t p = 1, g, den, num; 15: int k, j; 16: 17: var B = new QQ_t[n]; 18: var T = new ZZ_t[n]; 19: 20: B[0] = new QQ_t(1, 1); 21: if (n == 1) return B; 22: 23: T[1] = 1; 24: 25: for (k = 2; k &amp;lt; n; k&#43;&#43;) 26: { 27: T[k] = (k - 1) * T[k - 1]; 28: } 29: 30: for (k = 2; k &amp;lt; n; k&#43;&#43;) 31: { 32: for (j = k; j &amp;lt; n; j&#43;&#43;) 33: { 34: T[j] = (j - k) * T[j - 1] &#43; (j - k &#43; 2) * T[j]; 35: } 36: } 37: 38: for (k = 1; k &amp;lt; n; k&#43;&#43;) 39: { 40: p *= 4; 41: den = p * (p - 1); 42: num = (k &#43; k) * T[k]; 43: g = gcd(num, den); 44: B[k] = new QQ_t(num / g, den / g); 45: } 46: 47: return B; 48: } 49: 50: // Computes the first n even _absolute_ Bernoulli numbers.  51: // B[0], B[2], B[4], ..., B[2*n - 2] for n &amp;gt;= 1.  52: static QQ_t[] bernoulliS(int n) 53: { 54: // System.Diagnostics.Debug.Assert(n &amp;gt; 0);  55: 56: ZZ_t p = 1, den = 0, g; 57: int h = 0, j = 1, k, i; 58: bool tog = true; 59: 60: var B = new QQ_t[n]; 61: var T = new ZZ_t[n]; 62: 63: B[0] = new QQ_t(1, 1); 64: if (n == 1) return B; 65: 66: T[1] = 1; 67: 68: for (i = 3; i &amp;lt;= 2 * n; i&#43;&#43;) 69: { 70: if (tog) 71: { 72: p &amp;lt;&amp;lt;= 2; 73: den = (p - 1) &amp;lt;&amp;lt; 1; 74: 75: for (k = h&#43;&#43;; k &amp;gt; 0; k--) 76: T[k] &#43;= T[k &#43; 1]; 77: } 78: else 79: { 80: for (k = 1; k &amp;lt;= h; k&#43;&#43;) 81: T[k] &#43;= T[k - 1]; 82: 83: g = gcd(T[h], den); 84: B[j&#43;&#43;] = new QQ_t(T[h] / g, den / g); 85: } 86: tog = !tog; 87: } 88: 89: return B; 90: } 91: 92: static ZZ_t gcd(ZZ_t a, ZZ_t b) 93: { 94: ZZ_t x, y; 95: 96: if (a &amp;gt;= b) { x = a; y = b; } 97: else { x = b; y = a; } 98: 99: while (y != 0) 100: { 101: ZZ_t t = x % y; x = y; y = t; 102: } 103: 104: return x; 105: } 106: 107: static void Main() 108: { 109: int n = 100; 110: var B = bernoulliS(n); 111: 112: for (int i = 0; i &amp;lt; n; i&#43;&#43;) 113: { 114: System.Console.WriteLine(i &#43; &amp;#34; : &amp;#34; &#43; B[i]); 115: } 116: 117: System.Console.WriteLine(&amp;#34;Done&amp;#34;); 118: System.Console.ReadLine(); 119: } 120: } 121: } Generate a binomial ditribution[7] #include &amp;#34;nmath.h&amp;#34;#include &amp;#34;dpq.h&amp;#34;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;limits.h&amp;gt; #define repeat for(;;)  double rbinom(double nin, double pp) { /* FIXME: These should become THREAD_specific globals : */ static double c, fm, npq, p1, p2, p3, p4, qn; static double xl, xll, xlr, xm, xr; static double psave = -1.0; static int nsave = -1; static int m; double f, f1, f2, u, v, w, w2, x, x1, x2, z, z2; double p, q, np, g, r, al, alv, amaxp, ffm, ynorm; int i, ix, k, n; if (!R_FINITE(nin)) ML_WARN_return_NAN; r = R_forceint(nin); if (r != nin) ML_WARN_return_NAN; if (!R_FINITE(pp) || /* n=0, p=0, p=1 are not errors &amp;lt;TSL&amp;gt;*/ r &amp;lt; 0 || pp &amp;lt; 0. || pp &amp;gt; 1.)	ML_WARN_return_NAN; if (r == 0 || pp == 0.) return 0; if (pp == 1.) return r; if (r &amp;gt;= INT_MAX)/* evade integer overflow, and r == INT_MAX gave only even values */ return qbinom(unif_rand(), r, pp, /*lower_tail*/ 0, /*log_p*/ 0); /* else */ n = (int) r; p = fmin2(pp, 1. - pp); q = 1. - p; np = n * p; r = p / q; g = r * (n &#43; 1); /* Setup, perform only when parameters change [using static (globals): */ /* FIXING: Want this thread safe -- use as little (thread globals) as possible */ if (pp != psave || n != nsave) { psave = pp; nsave = n; if (np &amp;lt; 30.0) { /* inverse cdf logic for mean less than 30 */ qn = R_pow_di(q, n); goto L_np_small; } else { ffm = np &#43; p; m = (int) ffm; fm = m; npq = np * q; p1 = (int)(2.195 * sqrt(npq) - 4.6 * q) &#43; 0.5; xm = fm &#43; 0.5; xl = xm - p1; xr = xm &#43; p1; c = 0.134 &#43; 20.5 / (15.3 &#43; fm); al = (ffm - xl) / (ffm - xl * p); xll = al * (1.0 &#43; 0.5 * al); al = (xr - ffm) / (xr * q); xlr = al * (1.0 &#43; 0.5 * al); p2 = p1 * (1.0 &#43; c &#43; c); p3 = p2 &#43; c / xll; p4 = p3 &#43; c / xlr; } } else if (n == nsave) { if (np &amp;lt; 30.0) goto L_np_small; } /*-------------------------- np = n*p &amp;gt;= 30 : ------------------- */ repeat { u = unif_rand() * p4; v = unif_rand(); /* triangular region */ if (u &amp;lt;= p1) { ix = (int)(xm - p1 * v &#43; u); goto finis; } /* parallelogram region */ if (u &amp;lt;= p2) { x = xl &#43; (u - p1) / c; v = v * c &#43; 1.0 - fabs(xm - x) / p1; if (v &amp;gt; 1.0 || v &amp;lt;= 0.) continue; ix = (int) x; } else { if (u &amp;gt; p3) {	/* right tail */ ix = (int)(xr - log(v) / xlr); if (ix &amp;gt; n) continue; v = v * (u - p3) * xlr; } else {/* left tail */ ix = (int)(xl &#43; log(v) / xll); if (ix &amp;lt; 0) continue; v = v * (u - p2) * xll; } } /* determine appropriate way to perform accept/reject test */ k = abs(ix - m); if (k &amp;lt;= 20 || k &amp;gt;= npq / 2 - 1) { /* explicit evaluation */ f = 1.0; if (m &amp;lt; ix) { for (i = m &#43; 1; i &amp;lt;= ix; i&#43;&#43;) f *= (g / i - r); } else if (m != ix) { for (i = ix &#43; 1; i &amp;lt;= m; i&#43;&#43;) f /= (g / i - r); } if (v &amp;lt;= f) goto finis; } else { /* squeezing using upper and lower bounds on log(f(x)) */ amaxp = (k / npq) * ((k * (k / 3. &#43; 0.625) &#43; 0.1666666666666) / npq &#43; 0.5); ynorm = -k * k / (2.0 * npq); alv = log(v); if (alv &amp;lt; ynorm - amaxp) goto finis; if (alv &amp;lt;= ynorm &#43; amaxp) { /* stirling&amp;#39;s formula to machine accuracy */ /* for the final acceptance/rejection test */ x1 = ix &#43; 1; f1 = fm &#43; 1.0; z = n &#43; 1 - fm; w = n - ix &#43; 1.0; z2 = z * z; x2 = x1 * x1; f2 = f1 * f1; w2 = w * w; if (alv &amp;lt;= xm * log(f1 / x1) &#43; (n - m &#43; 0.5) * log(z / w) &#43; (ix - m) * log(w * p / (x1 * q)) &#43; (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / f2) / f2) / f2) / f2) / f1 / 166320.0 &#43; (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / z2) / z2) / z2) / z2) / z / 166320.0 &#43; (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / x2) / x2) / x2) / x2) / x1 / 166320.0 &#43; (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / w2) / w2) / w2) / w2) / w / 166320.) goto finis; } } } L_np_small: /*---------------------- np = n*p &amp;lt; 30 : ------------------------- */ repeat { ix = 0; f = qn; u = unif_rand(); repeat { if (u &amp;lt; f) goto finis; if (ix &amp;gt; 110) break; u -= f; ix&#43;&#43;; f *= (g / ix - r); } } finis: if (psave &amp;gt; 0.5) ix = n - ix; return (double)ix; } Poisson Ditribution more easy to compute than other:
# Include &amp;lt;stdio. h&amp;gt; # Include &amp;lt;math. h&amp;gt; # Include &amp;lt;time. h&amp;gt;  Double U_Random (); Int possion (); Void main () { Double u = U_Random (); Int p = possion (); Printf (&amp;#34;% fn&amp;#34;, u ); Printf (&amp;#34;% dn&amp;#34;, p ); } Int possion ()/* generates a random number with a Poisson distribution. Lamda is the average number */ { Int Lambda = 20, k = 0; Long double p = 1.0; Long double l = exp (-Lambda);/* it is defined as long double for precision, and exp (-Lambda) is a decimal near 0 */ Printf (&amp;#34;%. 15Lfn&amp;#34;, l ); While (p&amp;gt; = l) { Double u = U_Random (); P * = u; K &#43;&#43;; } Return K-1; } Double U_Random ()/* generates a 0 ~ Random number between 1 */ { Double f; Srand (unsigned) time (NULL )); F = (float) (rand () % 100 ); /* Printf (&amp;#34;% fn&amp;#34;, f );*/ Return f/100; } [1]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://en.wikipedia.org/wiki/List_of_probability_distributions&amp;quot; [2]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://www.cs.wm.edu/~va/software/park/park.html&amp;quot; [3]https://www.johndcook.com/blog/2010/05/03/c-random-number-generation-code/ [4]https://homeweb.csulb.edu/~tebert/teaching/lectures/552/variate/variate.pdf [5]https://www.jstor.org/stable/1402590 [6]https://www.icosaedro.it/phplint/generating-statistical-distributions/index.html
[7]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://svn.r-project.org/R/trunk/src/nmath/rbinom.c&amp;quot;
]]></content:encoded>
    </item>
    <item>
      <title>6_R</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_5/6r/</link>
      <pubDate>Sat, 23 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_5/6r/</guid>
      <description>6_R assignament Request Think and explain in your own words what is the role that probability plays in Statistics and the relation between the observed distribution and frequencies their &amp;ldquo;theoretical&amp;rdquo; counterparts. Do some practical examples where you explain how the concepts of an abstract probability space relate to more &amp;ldquo;concrete&amp;rdquo; and &amp;ldquo;real-world&amp;rdquo; objects when doing statistics.
The role of probability in statistic In statistcs when we talk about inference we move the contest from frequencies to a more interesting probability area, in this area we say for example that if a dice hit six with a frequencies of 1/6 (concrete) in the real world , we would have a probability of 1/6, note that probability is not about what happened, for if so then we do not need probability theory.</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[6_R assignament Request Think and explain in your own words what is the role that probability plays in Statistics and the relation between the observed distribution and frequencies their &amp;ldquo;theoretical&amp;rdquo; counterparts. Do some practical examples where you explain how the concepts of an abstract probability space relate to more &amp;ldquo;concrete&amp;rdquo; and &amp;ldquo;real-world&amp;rdquo; objects when doing statistics.
The role of probability in statistic In statistcs when we talk about inference we move the contest from frequencies to a more interesting probability area, in this area we say for example that if a dice hit six with a frequencies of 1/6 (concrete) in the real world , we would have a probability of 1/6, note that probability is not about what happened, for if so then we do not need probability theory. Probability is about what may happen. [1]
Relation between empircal case (distribution and frequencies) and theoretical starting from the same distribution let&amp;rsquo;try to analyze the two view:
   Theoretical distribution  Empirical distribution     Units Frequencies  Units Probability   X1 f1  X1 P1   Xn fn  Xn Pm    We could say so that frequency is an incarnation of probability, a realization in the real world of the abstract concept of probability and in this sense it&amp;rsquo;s easy to assume that the two fenomenus are goverend by the same law and that frequencies are just the actualization of the probability.
In inference statistics the objective is to determine which theta (we call it also states of nature) is the most probable so the one that can generate sample of empirical distribution (evidence) equivalent to the real one.
The methods of Bayesian inference You can never be certain about a hypothesis, but as the availability and dimension of data increases, the quality of the inference becomes better and better; with sufficient empirical evidence, it will become very high (for example, tending to 1) or very low (tending to 0). this represent a sort of implementation of the scientific method which normally involves the collection of data (empirical evidence), and hypothesis, here the hypothesis are the probability distributions that more rappresent the real fact.
In practice we have:
 P(θ|E)  Where θ is the state of nature that can could be an array of values or a single value and E the evidence. So, referring to the frequencies, we have that for frequencies in an empirical contest we have that:
 Freq(X|Y)=Freq(X∧Y)/Freq(Y)  Where X and Y are just labels and this is an identity. With
 P(X|Y)=P(X∧Y)/P(Y)  we are in the realm of probability, so a branch of mathematics, and this is the definition for conditional probability.
[1]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://math.stackexchange.com/questions/1443015/why-do-we-say-almost-surely-in-probability-theory&amp;quot; [2]&amp;ldquo;url&amp;quot;&amp;ldquo;https://en.wikipedia.org/wiki/Probability_axioms&amp;quot;
]]></content:encoded>
    </item>
    <item>
      <title>7_A</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_5/7a/</link>
      <pubDate>Sat, 23 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_5/7a/</guid>
      <description>7_A assignament Request Given 2 variables from a csv compute and represent the statistical regression lines (X to Y and viceversa) and the scatterplot. Optionally, represent also the histograms on the &amp;ldquo;sides&amp;rdquo; of the chart (one could be draw vertically and the other one horizontally, in the position that you prefer). [Remember that all our charts must alway be done within &amp;ldquo;dynamic viewports&amp;rdquo; (movable/resizable rectangles). No third party libraries, to ensure ownership of creative process.</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[7_A assignament Request Given 2 variables from a csv compute and represent the statistical regression lines (X to Y and viceversa) and the scatterplot. Optionally, represent also the histograms on the &amp;ldquo;sides&amp;rdquo; of the chart (one could be draw vertically and the other one horizontally, in the position that you prefer). [Remember that all our charts must alway be done within &amp;ldquo;dynamic viewports&amp;rdquo; (movable/resizable rectangles). No third party libraries, to ensure ownership of creative process. May choose the language you prefer.].
My Solution   Code in C#
Class Main Form in C# public partial class Bivarianteform : Form { public Bivarianteform() { InitializeComponent(); contb = new Bitmap(755, 681); g2 = Graphics.FromImage(contb); } Dictionary&amp;lt;int, ElementoDisribuzione&amp;gt; csvContent = new Dictionary&amp;lt;int, ElementoDisribuzione&amp;gt;(); Distribuzione distr = new Distribuzione(); MediaCalOnline medie = new MediaCalOnline(); String[,] bivariantMatrix; List&amp;lt;String&amp;gt; attributename = new List&amp;lt;string&amp;gt;(); List&amp;lt;String&amp;gt; bivariante = new List&amp;lt;string&amp;gt;();//per ora poi diventera n variante;  Bitmap contb; Graphics g2; List&amp;lt;PointF&amp;gt; points = new List&amp;lt;PointF&amp;gt;(); List&amp;lt;PointF&amp;gt; regressiony = new List&amp;lt;PointF&amp;gt;(); List&amp;lt;PointF&amp;gt; regressionx = new List&amp;lt;PointF&amp;gt;(); Matrix m = new Matrix(); Matrix m2 = new Matrix(); Matrix m3 = new Matrix(); int nr, nc; //Distributions  SortedDictionary&amp;lt;Tuple&amp;lt;double, double&amp;gt;, int&amp;gt; firstdistr; SortedDictionary&amp;lt;Tuple&amp;lt;double, double&amp;gt;, int&amp;gt; seconddistr; bool movable = false; bool resiable = false; // movable view port  int contgleft = 0; int contgtop = 50; int contgwid = 400; int contgheight = 400; int mouseDeltax=0; int mouseDeltay=0; // window  double minX_Window = 0; double maxX_Window = 400; double minY_Window = 0; double maxY_Window = 400; Rectangle viewPortcontig=new Rectangle(0,50, 400, 400); private void button1_Click(object sender, EventArgs e) { var filePath = string.Empty; openFileDialog1.InitialDirectory = &amp;#34;c:\\&amp;#34;; openFileDialog1.Filter = &amp;#34;csv files (*.csv)|*.csv|All files (*.*)|*.*&amp;#34;; openFileDialog1.FilterIndex = 2; openFileDialog1.RestoreDirectory = true; if (openFileDialog1.ShowDialog() == DialogResult.OK) { //Get the path of specified file  filePath = openFileDialog1.FileName; //Read the contents of the file into a stream  using (TextFieldParser csvParser = new TextFieldParser(filePath)) { csvParser.CommentTokens = new string[] { &amp;#34;#&amp;#34; }; csvParser.SetDelimiters(new string[] { &amp;#34;,&amp;#34; }); csvParser.HasFieldsEnclosedInQuotes = true; // Save the row with the column names  string[] fieldsNames = csvParser.ReadFields(); attributename.AddRange(fieldsNames); int i = 0; while (!csvParser.EndOfData) { // Read current line fields, pointer moves to the next line.  string[] fields = csvParser.ReadFields(); ElementoDisribuzione elem = new ElementoDisribuzione(fields[0]); int j = 0; foreach (String field in fields) { if (!String.IsNullOrEmpty(field)) { double tmp; if (Double.TryParse(field, out tmp)) { elem.setVariable(fieldsNames[j], new Tuple&amp;lt;Object, Type&amp;gt;(tmp, tmp.GetType())); medie.addAttribute(fieldsNames[j], tmp); } else elem.setVariable(fieldsNames[j], new Tuple&amp;lt;Object, Type&amp;gt;(field, field.GetType())); } j&#43;&#43;; } csvContent.Add(i, elem); distr.addElementoDef(elem); i&#43;&#43;; } } button2.Visible = true; } } private void button2_Click(object sender, EventArgs e) { ; foreach (var elem in attributename) contextMenuStrip1.Items.Add(elem); contextMenuStrip1.Visible = true; } private void contextMenuStrip1_Opening(object sender, CancelEventArgs e) { } private void contextMenuStrip1_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { bivariante.Add(e.ClickedItem.Text); button2.Visible = false; foreach (var elem in attributename) contextMenuStrip2.Items.Add(elem); contextMenuStrip2.Visible = true; } private void contextMenuStrip2_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { bivariante.Add(e.ClickedItem.Text); double mediax = 0; double mediay = 0; double sigmax2=0; double sigmay2=0; double sigmaxy=0; bool isDouble = false; List&amp;lt;Double&amp;gt; valuesx = new List&amp;lt;double&amp;gt;(0); List&amp;lt;Double&amp;gt; valuesy = new List&amp;lt;double&amp;gt;(0); medie.getMedia(bivariante.ElementAt(0), out mediax); //se la media è diversa da zero sono sicuro che è double  medie.getMedia(bivariante.ElementAt(1), out mediay); if (mediax != 0) { if (mediay != 0) { isDouble = true; Tuple&amp;lt;Object, Type&amp;gt; tmp; foreach (var elm in csvContent.Values) { elm.getVariable(bivariante.ElementAt(0), out tmp); valuesx.Add((double)tmp.Item1); elm.getVariable(bivariante.ElementAt(1), out tmp); valuesy.Add((double)tmp.Item1); } medie.getdDeviation2(bivariante.ElementAt(0), valuesx, out sigmax2); distr.getdistribuzioneN(bivariante.ElementAt(0), out firstdistr); medie.getdDeviation2(bivariante.ElementAt(1), valuesy, out sigmay2); distr.getdistribuzioneN(bivariante.ElementAt(1), out seconddistr); medie.getbivariantDeviation(bivariante.ElementAt(0), bivariante.ElementAt(1), valuesx,valuesy, out sigmaxy); for (int i = 0; i &amp;lt;= maxX_Window; i&#43;&#43;) { regressionx.Add(new PointF(i, (float) (((sigmaxy / sigmax2) * (i - mediax)) &#43; mediay))); } for (int i = 0; i &amp;lt;= maxY_Window; i&#43;&#43;) { regressiony.Add(new PointF((float)(((sigmaxy / sigmay2) * (i - mediay)) &#43; mediax), i)); } } } bivariantMatrix = distr.getbivariantmatrix(bivariante, csvContent.Values, out nr, out nc); this.button3.Visible = true; } private void button3_Click(object sender, EventArgs e) { creaGrafici(); } private void creaGrafici() { foreach (var elem in csvContent) { Tuple&amp;lt;Object, Type&amp;gt; a, b; float x, y; elem.Value.getVariable(bivariante.ElementAt(0), out a); elem.Value.getVariable(bivariante.ElementAt(1), out b); x = (float)(double)a.Item1; y = (float)(double)b.Item1; points.Add(new PointF(x, y)); } //contingency  createconting(g2, 0, 50,400,400); } private void createconting(Graphics g2, int dinamicleft, int dinamictop,int contgw,int contgh) { viewPortcontig.X = dinamicleft; viewPortcontig.Y = dinamictop; viewPortcontig.Width = contgw; viewPortcontig.Height = contgh; //viewPortcontig.Location= new Point(viewPortcontig.Location.X&#43;dinamicleft,viewPortcontig.Location.Y&#43;dinamictop);  g2.Clear(BackColor); g2.FillRectangle(Brushes.White, viewPortcontig); // window drow  g2.DrawLine(new Pen(Color.Black, 2), viewPortcontig.X, viewPortcontig.Y, viewPortcontig.X, (viewPortcontig.Y &#43; viewPortcontig.Height)); g2.DrawLine(new Pen(Color.Black, 2), viewPortcontig.X, (viewPortcontig.Y &#43; viewPortcontig.Height), (viewPortcontig.X &#43; viewPortcontig.Width), (viewPortcontig.Y &#43; viewPortcontig.Height)); m.Reset(); m.Translate(-(int)minX_Window, -(int)minY_Window, MatrixOrder.Append); m.Scale((int)(viewPortcontig.Width / (maxX_Window - minX_Window)), (int)(-viewPortcontig.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m.Translate(viewPortcontig.Left, viewPortcontig.Top &#43; viewPortcontig.Height, MatrixOrder.Append); PointF[] myPoints = points.ToArray(); PointF[] myPointsreal = points.ToArray(); PointF[] pRegressionx = regressionx.ToArray(); PointF[] pRegressiony = regressiony.ToArray(); int i = 0; m.TransformPoints(myPoints); m.TransformPoints(pRegressionx); m.TransformPoints(pRegressiony); foreach (PointF punto in myPoints) { if (myPointsreal[i].X &amp;lt;= maxX_Window &amp;amp;&amp;amp; myPointsreal[i].Y &amp;lt;= maxY_Window) { g2.FillEllipse(Brushes.Black, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); g2.DrawString(myPointsreal[i].ToString(), new Font(&amp;#34;Arial&amp;#34;, 10), Brushes.Black, (int)(punto.X), (int)(punto.Y)); g2.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(punto.X - 2), (int)(viewPortcontig.Y &#43; viewPortcontig.Height - 2)), new Size(4, 4))); g2.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(viewPortcontig.X), (int)(punto.Y - 2)), new Size(4, 4))); } i&#43;&#43;; ; } foreach (PointF punto in pRegressionx) { g2.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); } foreach (PointF punto in pRegressiony) { g2.FillEllipse(Brushes.Green, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); } pictureBox2.Image = contb ; } private void pictureBox2_MouseDown(object sender, MouseEventArgs e) { if ( (e.Location.Y&amp;gt;=viewPortcontig.Top &amp;amp;&amp;amp;e.Location.Y &amp;lt;= (viewPortcontig.Top&#43;viewPortcontig.Height))&amp;amp;&amp;amp;(e.Location.X &amp;gt;= viewPortcontig.Left &amp;amp;&amp;amp; e.Location.X &amp;lt;= (viewPortcontig.Left &#43; viewPortcontig.Width))) { if (e.Button == MouseButtons.Left) movable = true; if (e.Button == MouseButtons.Right) resiable = true; mouseDeltax = e.Location.X; mouseDeltay = e.Location.Y; } } private void pictureBox2_MouseLeave(object sender, EventArgs e) { resiable = false; movable = false; } private void pictureBox2_MouseMove(object sender, MouseEventArgs e) { if (movable == true) { contgleft = e.Location.X; contgtop = e.Location.Y; if (contgleft &amp;lt;= 0) contgleft = 0; if (contgtop &amp;lt;= 20) contgtop = 20; createconting(g2, contgleft, contgtop, contgwid, contgheight); } if (resiable == true) { mouseDeltax = -mouseDeltax &#43; e.Location.X ; mouseDeltay = -mouseDeltay &#43; e.Location.Y; contgwid &#43;= mouseDeltax/40; contgheight &#43;= mouseDeltay/40; createconting(g2, contgleft, contgtop, contgwid, contgheight); } } private void pictureBox2_MouseUp(object sender, MouseEventArgs e) { resiable = false; movable = false; } } }  ]]></content:encoded>
    </item>
    <item>
      <title>7_R</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_5/7r/</link>
      <pubDate>Sat, 23 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_5/7r/</guid>
      <description>7_R assignament Request Explain the Bayes Theorem and its key role in statistical induction. Describe the different paradigs that can be found within statistical inference (such as&amp;quot;bayesian&amp;quot;, &amp;ldquo;frequentist&amp;rdquo; [Fisher, Neyman]).
The Bayes Theorem Bayes&#39; theorem is used to calculate the probability of a cause that triggered the occurred event, and the importance of this theorem for statistics is such that different interpretation and usage divided the statisticians into two schools Bayesian and Frequentist</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[7_R assignament Request Explain the Bayes Theorem and its key role in statistical induction. Describe the different paradigs that can be found within statistical inference (such as&amp;quot;bayesian&amp;quot;, &amp;ldquo;frequentist&amp;rdquo; [Fisher, Neyman]).
The Bayes Theorem Bayes&#39; theorem is used to calculate the probability of a cause that triggered the occurred event, and the importance of this theorem for statistics is such that different interpretation and usage divided the statisticians into two schools Bayesian and Frequentist
P(A|B)=(P(B|A)P(A))/P(B)
Frequentist and Bayesian statistics we called this therm prior probability.
Frequentist According to the frequentist definition of probability, only repeatable random events (like a dice rool) have probabilities. These probabilities are equal to the long-term frequency of occurrence of the events in question. Frequentists don’t attach probabilities to hypotheses or to any fixed but unknown values in general. [1] Basically, a frequentist method makes predictions on the underlying truths of the experiment using only data from the current experiment.
Bayesian Bayesians view probabilities as a more general concept a Bayesian can use probabilities to represent the uncertainty in any event or hypothesis. [1]
Statistical infernce paradigm So, the biggest distinction is that Bayesian probability specifies that there is some prior probability. The division between the two schools of thought occurs because of the term P(B) (P(θ) in the classroom)
   The Frequentist The Bayesian     chose to ignore the term and assign it a uniform distribution choose to use a certain already calculated shape distribution(like bernulli etc..)    [1]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://en.wikipedia.org/wiki/Bayes%27_theor&amp;quot;
]]></content:encoded>
    </item>
  </channel>
</rss>
