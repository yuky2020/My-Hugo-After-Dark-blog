<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>Week 6 HW on Matteo Bianchi personal site and blog</title>
    <link>https://www.matteobianchi.eu/statistics-posts/week_6/</link>
    <description>Recent content in Week 6 HW on Matteo Bianchi personal site and blog</description>
    <image>
      <title>Week 6 HW on Matteo Bianchi personal site and blog</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_6/</link>
      <url>https://source.unsplash.com/collection/983219/2000x1322</url>
    </image>
    <ttl>1440</ttl>
    <generator>After Dark 9.2.3 (Hugo 0.80.0)</generator>
    <language>en-US</language>
    <lastBuildDate>Fri, 04 Feb 2022 15:08:14 UT</lastBuildDate>
    <atom:link href="https://www.matteobianchi.eu/statistics-posts/week_6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>6_RA</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_6/6ra/</link>
      <pubDate>Thu, 28 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_6/6ra/</guid>
      <description>6_RA assignament Request Do a web research about the various methods proposed to compute the running median (one pass, online algorithms). Store (cite all sources and attributions) the algorithm(s) that you think is(are) a good candidate, explaining briefly how it works and possibly try a quick demo.
Compute it with one pass the median is the value that is at the center of the distribution and biscet it,for computing it we can use a simple algo: Starting from a ordered distribution (cardinality n) whe could say that:</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[6_RA assignament Request Do a web research about the various methods proposed to compute the running median (one pass, online algorithms). Store (cite all sources and attributions) the algorithm(s) that you think is(are) a good candidate, explaining briefly how it works and possibly try a quick demo.
Compute it with one pass the median is the value that is at the center of the distribution and biscet it,for computing it we can use a simple algo: Starting from a ordered distribution (cardinality n) whe could say that:
 if the number of value are odd we can take the value placed at (n&#43;1)/2 as the median if the number of value is even we take the two value in the middle (at index n/2 and n/2&#43;1) and compute the mean between the two value as the median  how to calculate it with an oline algo we can approssimate the median with the formula: [1] Me= Xi&#43;(Xi&#43;1 -Xi)=(0,5 -Fi)/(Fi&#43;1-Fi) where Fi are the acutual comulative frequency and calculate it online with this
Efficient Algorithm for computing a Running Median From -LIGO- LASER INTERFEROMETER GRAVITATIONAL WAVE OBSERVATORY[2]
Inputs to the code: • X : the sequence x[k], k = 0, . . . , N − 1. • M : The number of points per block. Output of the code: • Y : sequence y[k], k = 0, . . . , N − M.
  1 Sort the first M samples x[k], k = 0, . . . , M −1, in ascending order. The ANSI C &amp;lt;stdlib.h&amp;gt; library comes with a routine for sorting called qsort which can be used for this first step. Let the sorted list, in ascending order, be Z[k], k = 0, . . . , M − 1. Thus, Z[0] ≤ Z[1] ≤ Z[2] . . . ≤ Z[M − 1].
  2 Load the sorted samples into the nodes of a linked list [6] with each node containing one sample. Each node of the linked list has three types of links to other nodes. Sequential link If the current node has sample x[p], then this link points to the node containing x[p &#43; 1]. Next Sorted link If the current node has sample Z[p], then this link points to the node containing Z[p &#43; 1]. Previous Sorted link If the current node has sample Z[p], then this link points to the node containing Z[p−1]. In the qsort algorithm, the ordering of equal samples is arbitrary and so is it assumed here.
  3 Set up an array, checks, of pointers to nodes of the linked list such that checks[n] points to the node containing Z h n ∗ floor ³√ M ´i. The special nodes pointed to by elements of checksare called checkpoints in the following. Further denote the samples contained in checkpoint p by C[p] = Z h p ∗ floor ³√ M ´i, p = 0, . . . , floor(√ M) − 1. Why are the checkpoints spaced √ M samples apart? Once one obtains a sorted block of M samples, the sequentially next sample outside this block must be placed in the sorted list and the sequentially first sample in the block must be deleted. This is done by first comparing the new sample sequentially against the samples 4 in checkpoints. Once the checkpoints that bracket the new sample are found, comparisons are made with only the samples within this bracket to locate the exact position of the new sample in the sorted list. This implies that in the worst case P comparison operations are needed, if P is the number of checkpoints used, to find the bracketing checkpoints. After this one may have to make M/P further comparisons to locate the exact position of the new sample in the ordered list. Thus the total operation count K, in the worst case, is K = P &#43; M/P . (2) The value of P which minimises K is P = √ M. This is why checkpoints are spaced M/P = M/√ M = √ M samples apart in this algorithm.
  4 Find the element n0 of checkssuch that the sample in the corresponding node is nearest to the node containing the median (for M odd) or the first member of the pair which needs to be averaged (for M even). This element will provide a fast access to the node containing the samples needed to compute the median. This is necessary because we are dealing with a linked list and not an array that can be randomly accessed.
  5 FOR j = M TO N − 1 DO
 (a) Get sample x[j]. (b) Locate the element pj of checks such that C[pj ] ≤ x[j] &amp;lt; C[pj &#43; 1]. (c) Start from the node checks[pj ] and follow the Next Sorted link until a node is found such that the sample value h it contains satisfies x[j] ≤ h. We have thus found the exact place where the new sample x[j] must be inserted. The next few steps find out the checkpoints that are bracketed by x[j] and the sample to be deleted, x[j − M]. When the corresponding nodes are respectively inserted and deleted from the list, the bracketed checlpoints must be shifted to adjacent nodes. (d) Consider the node containing the first element of the sequential list. That sample will be x[j − M]. (e) Find elements q and p of checks such that i. If x[j − M] &amp;lt; x[j] x(j − M) &amp;lt; C[q] &amp;lt; . . . &amp;lt; C[p] &amp;lt; x[j] ii. else if x[j − M] &amp;gt; x[j] x[j] &amp;lt; C[p &#43; 1] &amp;lt; . . . &amp;lt; C[q] &amp;lt; x[j − M]. iii. else if x[j − M] == x[j] Do nothing. No shifting of checkpoints required since in this case all samples in the sorted list between x[j] and x[j − M] must be equal to x[j] = x[j − M]. (f) Shift the checkpoints found in step 5e. i. If x[j − M] &amp;lt; x[j] Shift each pointer checks[k], k ∈ [q, p], to point to the next right node (i.e., higher in sorted order). ii. Else shift to the next left node. (g) Delete node containing x[j − M] from the linked list (repair the links between the nodes adjacent to it). (h) Rewrite the data in this node by x[j]. (i) Insert this node before the node containing h. (j) Follow Next Sorted link from checks[n0] to get the median value.    6 END DO
  Several special cases may arise such as x[j] smaller or larger than any of the sample from the previous block. A lot of the code is devoted to handling such special cases.
[1]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://dcc-backup.ligo.org/public/0027/T030168/000/T030168-00.pdf&amp;quot; [2]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://it.wikipedia.org/wiki/Mediana_(statistica)#Definizione_e_calcolo&amp;quot;
]]></content:encoded>
    </item>
    <item>
      <title>8_A</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_6/8a/</link>
      <pubDate>Thu, 28 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_6/8a/</guid>
      <description>8_A assignament Request Generate and represent m &amp;ldquo;sample paths&amp;rdquo; of n point each (m, n are program parameters), where each point represents a pair of: time index t, and relative frequency of success f(t),
where f(t) is the sum of t Bernoulli random variables with distribution B(x, p) = p^x(1-p)^(1-x) observed at the various times up to t: j=1, &amp;hellip;, t..
At time n (last time) and one other chosen inner time 1&amp;lt;j&amp;lt;n (where j is a user parameter) represent with a histogram the distribution of f(t).</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[8_A assignament Request Generate and represent m &amp;ldquo;sample paths&amp;rdquo; of n point each (m, n are program parameters), where each point represents a pair of: time index t, and relative frequency of success f(t),
where f(t) is the sum of t Bernoulli random variables with distribution B(x, p) = p^x(1-p)^(1-x) observed at the various times up to t: j=1, &amp;hellip;, t..
At time n (last time) and one other chosen inner time 1&amp;lt;j&amp;lt;n (where j is a user parameter) represent with a histogram the distribution of f(t). See also what happens if you replace the relative frequency f(t) with the absolute frequency n(t) or by standard relative frequency: (f(t)-p) / sqrt(p(1-p)/t) [ or simply the &amp;ldquo;normalized&amp;rdquo; sum of bernoulli r.v.&amp;rsquo;s: n(t) / Math.sqrt(t) ].
Comment briefly on the convergence results you see.
My Solution   Code in C#
Class Main Form in C# public partial class BernulliGraphics : Form { public BernulliGraphics() { InitializeComponent(); contb = new Bitmap(755, 681); g2 = Graphics.FromImage(contb); comboBox1.SelectedIndex = 0; } Bitmap contb; Graphics g2; bool movable = false; bool resiable = false; // movable view port  int contgleft = 0; int contgtop = 50; int contgwid = 400; int contgheight = 400; int mouseDeltax = 0; int mouseDeltay = 0; // window  double minX_Window = 0; double maxX_Window = 400; double minY_Window = 0; double maxY_Window = 400; Rectangle viewPortc = new Rectangle(0, 50, 600, 600); private void button1_Click(object sender, EventArgs e) { creaGrafici(); } private void creaGrafici() { bool is_abs = false; if (comboBox1.SelectedIndex == 1) is_abs = true; int m = (int)this.numericUpDown1.Value; int n = (int)this.numericUpDown2.Value; double p = (double)this.numericUpDown3.Value / 100; int j = 40; double epsilon = (double)this.numericUpDown4.Value; DisegnaGrafici gr = new DisegnaGrafici(m, n, j, g2, p, epsilon, viewPortc, contgleft, contgtop, contgwid, contgheight, textBox1, textBox2,is_abs); gr.getGrapichs(); pictureBox2.Image = contb; } private void pictureBox2_MouseDown(object sender, MouseEventArgs e) { if ((e.Location.Y &amp;gt;= viewPortc.Top &amp;amp;&amp;amp; e.Location.Y &amp;lt;= (viewPortc.Top &#43; viewPortc.Height)) &amp;amp;&amp;amp; (e.Location.X &amp;gt;= viewPortc.Left &amp;amp;&amp;amp; e.Location.X &amp;lt;= (viewPortc.Left &#43; viewPortc.Width))) { if (e.Button == MouseButtons.Left) movable = true; if (e.Button == MouseButtons.Right) resiable = true; mouseDeltax = e.Location.X; mouseDeltay = e.Location.Y; } } private void pictureBox2_MouseLeave(object sender, EventArgs e) { resiable = false; movable = false; } private void pictureBox2_MouseMove(object sender, MouseEventArgs e) { if (movable == true) { contgleft = e.Location.X; contgtop = e.Location.Y; if (contgleft &amp;lt;= 0) contgleft = 0; if (contgtop &amp;lt;= 20) contgtop = 20; creaGrafici(); } if (resiable == true) { mouseDeltax = -mouseDeltax &#43; e.Location.X; mouseDeltay = -mouseDeltay &#43; e.Location.Y; contgwid &#43;= mouseDeltax / 40; contgheight &#43;= mouseDeltay / 40; creaGrafici(); } } private void pictureBox2_MouseUp(object sender, MouseEventArgs e) { resiable = false; movable = false; } private void comboBox1_SelectedIndexChanged(object sender, EventArgs e) { creaGrafici(); } }  DisegnaGrafici class public class DisegnaGrafici { public Bitmap bitmap; public Graphics g2; public PictureBox pictureBox; private int SCALE = 10; private Random R = new Random(); public List&amp;lt;Strade&amp;gt; viewPortPaths; public List&amp;lt;Strade&amp;gt; viewPortAbsolute; private Rectangle viewPort; Matrix m1; BernulliPathfinder bernulli; public DisegnaGrafici(int m, int n, int j, Graphics graphics, double p, double epsilon, Rectangle vPort, int dinamicleft, int dinamictop, int contgw, int contgh, TextBox boxassfreq, TextBox boxrelfreq, bool is_abs) { this.g2 = graphics; this.viewPort = vPort; this.viewPort.X = dinamicleft; this.viewPort.Y = dinamictop; this.viewPort.Width = contgw; this.viewPort.Height = contgh; this.m1 = new Matrix(); g2.Clear(Color.Transparent); g2.FillRectangle(Brushes.Transparent, this.viewPort); g2.DrawRectangle(new Pen(Color.Black), this.viewPort); //genero la marice per le trasformazioni  m1.Reset(); m1.Translate(-0, -(int)0, MatrixOrder.Append); m1.Scale((int)(viewPort.Width / (n - 0)), (int)(-viewPort.Height / (1 - 0)), MatrixOrder.Append); m1.Translate(viewPort.Left, viewPort.Top &#43; viewPort.Height, MatrixOrder.Append); //genero le &amp;#34;strade&amp;#34;  bernulli = new BernulliPathfinder(n, m, p); //disegno i vari path convertendoli per il viewport  if (is_abs) disegnaABSPaths(fromPathstoAbsViewport(bernulli.paths, viewPort,n)); else { disegnaPaths(fromPathstoViewport(bernulli.paths, viewPort)); disegnaHistogramma(viewPort, getDistribution(bernulli.paths, m / SCALE, j), n, j); disegnaHistogramma(viewPort, getDistribution(bernulli.paths, m / SCALE, n), n, n); } getAbsoluteFrequencies(bernulli.paths, n, m, p, epsilon, boxassfreq, boxrelfreq); } private void disegnaABSPaths(List&amp;lt;List&amp;lt;PointF&amp;gt;&amp;gt; viewPortABSPaths) { for (int i = 0; i &amp;lt; viewPortABSPaths.Count; i&#43;&#43;) { Pen pen = new Pen(Color.FromArgb(R.Next(0, 255), R.Next(0, 255), R.Next(0, 255))); for (int j = 0; j &amp;lt; viewPortABSPaths[i].Count - 1; j&#43;&#43;) { g2.DrawLine(pen, (float)viewPortABSPaths[i][j].X, (float)viewPortABSPaths[i][j].Y, (float)viewPortABSPaths[i][j &#43; 1].X, (float)viewPortABSPaths[i][j &#43; 1].Y); } } } public List&amp;lt;List&amp;lt;PointF&amp;gt;&amp;gt; fromPathstoAbsViewport(List&amp;lt;Strade&amp;gt; paths, Rectangle viewPort,int n) { List&amp;lt;List&amp;lt;PointF&amp;gt;&amp;gt; viewPortAbsPaths = new List&amp;lt;List&amp;lt;PointF&amp;gt;&amp;gt;(); float tmpy = 0; float tmpx = 0; foreach (Strade path in paths) { tmpy = 0; tmpx = 0; List&amp;lt;PointF&amp;gt; abtmp = new List&amp;lt;PointF&amp;gt;(); foreach (int p in path.values) { if (p == 1) tmpy&#43;&#43;; tmpx&#43;&#43;; //only for graphic it rapidly  abtmp.Add(new PointF(tmpx, (tmpy / n))); } PointF[] viewPortArrayPath = abtmp.ToArray(); this.m1.TransformPoints(viewPortArrayPath); viewPortAbsPaths.Add(viewPortArrayPath.ToList()); } return viewPortAbsPaths; } public void getAbsoluteFrequencies(List&amp;lt;Strade&amp;gt; paths, int n, int m, double p, double epsilon, TextBox boxassfreq, TextBox boxrelfreq) { Intervalli p_neighbourhood = new Intervalli(p - epsilon, p &#43; epsilon); int absolute_frequency = 0; double relative_frequency = 0; foreach (Strade path in paths) { for (int i = 0; i &amp;lt; path.getPath().Count; i&#43;&#43;) { if ( (path.getPath()[i].X == n) &amp;amp;&amp;amp; (path.getPath()[i].Y &amp;gt;= p_neighbourhood.LowerBound) &amp;amp;&amp;amp; (path.getPath()[i].Y &amp;lt; p_neighbourhood.UpperBound) ) { absolute_frequency&#43;&#43;; } } } relative_frequency = (double)absolute_frequency / (double)m; boxassfreq.Text = absolute_frequency.ToString(); boxrelfreq.Text = relative_frequency * 100 &#43; &amp;#34;%&amp;#34;; } public void disegnaPaths(List&amp;lt;Strade&amp;gt; viewPortPaths) { for (int i = 0; i &amp;lt; viewPortPaths.Count; i&#43;&#43;) { Pen pen = new Pen(Color.FromArgb(R.Next(0, 255), R.Next(0, 255), R.Next(0, 255))); for (int j = 0; j &amp;lt; viewPortPaths[i].getPath().Count - 1; j&#43;&#43;) { g2.DrawLine(pen, (float)viewPortPaths[i].getPath()[j].X, (float)viewPortPaths[i].getPath()[j].Y, (float)viewPortPaths[i].getPath()[j &#43; 1].X, (float)viewPortPaths[i].getPath()[j &#43; 1].Y); } } } public void disegnaHistogramma(Rectangle viewPort, List&amp;lt;Intervalli&amp;gt; intervals, int n, int j) { for (int i = 0; i &amp;lt; intervals.Count; i&#43;&#43;) { int x, y; int width, height; // in this case on the fly trasformation is way faster  x = (int)(this.viewPort.Left &#43; this.viewPort.Width * (j) / n); y = (int)(viewPort.Top &#43; viewPort.Height * ((100 - intervals[i].UpperBound * 100) / 100)); width = intervals[i].Counter; height = viewPort.Height / intervals.Count; Rectangle rectangle = new Rectangle(x, y, width, height); g2.DrawRectangle(Pens.Black, rectangle); SolidBrush semiTransBrush = new SolidBrush(Color.FromArgb(128, 150, 0, 0)); g2.FillRectangle(semiTransBrush, rectangle); g2.FillRectangle(Brushes.Violet, rectangle); } } public List&amp;lt;Intervalli&amp;gt; getDistribution(List&amp;lt;Strade&amp;gt; paths, int noIntervals, int j) { List&amp;lt;double&amp;gt; frequencies = new List&amp;lt;double&amp;gt;(); for (int i = 0; i &amp;lt; paths.Count; i&#43;&#43;) { for (int k = 0; k &amp;lt; paths[i].getPath().Count; k&#43;&#43;) { if (paths[i].getPath()[k].X == j) { frequencies.Add(paths[i].getPath()[k].Y); } } } List&amp;lt;Intervalli&amp;gt; intervals = new List&amp;lt;Intervalli&amp;gt;(); double intervalLength = 1.0 / (double)noIntervals; for (int i = 0; i &amp;lt; noIntervals; i&#43;&#43;) { intervals.Add(new Intervalli(i * intervalLength, (i &#43; 1) * intervalLength)); } for (int i = 0; i &amp;lt; intervals.Count; i&#43;&#43;) { for (int k = 0; k &amp;lt; frequencies.Count; k&#43;&#43;) { if ((frequencies[k] &amp;gt;= intervals[i].LowerBound) &amp;amp;&amp;amp; (frequencies[k] &amp;lt; intervals[i].UpperBound)) { intervals[i].Counter&#43;&#43;; } } } return intervals; } public List&amp;lt;Strade&amp;gt; fromPathstoViewport(List&amp;lt;Strade&amp;gt; paths, Rectangle viewPort) { List&amp;lt;Strade&amp;gt; viewPortPaths = new List&amp;lt;Strade&amp;gt;(); foreach (Strade path in paths) { PointF[] viewPortArrayPath = path.getPath().ToArray(); this.m1.TransformPoints(viewPortArrayPath); viewPortPaths.Add(new Strade(viewPortArrayPath.ToList())); } return viewPortPaths; } public Graphics getGrapichs() { return this.g2; } }  BernoulliPathfinder (Class with bernulli random variable creation methods) public class BernulliPathfinder { int m; //number of paths  int n; //number of points  double p; //probability  public List&amp;lt;Strade&amp;gt; paths = new List&amp;lt;Strade&amp;gt;(); private Random R; public BernulliPathfinder(int n, int m, double p) { this.m = n; this.n = m; this.p = p; this.R = new Random(); for (int i=0; i &amp;lt; m; i&#43;&#43;) { paths.Add(new Strade(createBernulliList())); } } private int bernoulli_Result(double p) { double random_outcome = R.NextDouble(); if (random_outcome &amp;lt;= p) return 1; else return 0; } private List&amp;lt;int&amp;gt; createBernulliList() { List&amp;lt;int&amp;gt; bernoulli = new List&amp;lt;int&amp;gt;(); for (int i = 0; i &amp;lt; n; i&#43;&#43;) { bernoulli.Add(bernoulli_Result(p)); } return bernoulli; } }  Strade.cs (path struct creation and useful methods) public class Strade { public List&amp;lt;PointF&amp;gt; path = new List&amp;lt;PointF&amp;gt;(); public List&amp;lt;int&amp;gt; values = new List&amp;lt;int&amp;gt;(); //Dalla lista di valori passo ai punti ;  public Strade(List&amp;lt;int&amp;gt; values) { this.values = values; double mean = 0; for (int i=0; i &amp;lt; values.Count; i&#43;&#43;) { if (i == 0) { mean = values[0]; } else { mean &#43;= (values[i] - mean) / (double)(i &#43; 1); } path.Add(new PointF(i &#43; 1, (float) mean)); } } public Strade(List&amp;lt;PointF&amp;gt; points) { path = points; } public List&amp;lt;double&amp;gt; getXs() { List&amp;lt;double&amp;gt; x_coordinates = new List&amp;lt;double&amp;gt;(); foreach (PointF p in this.getPath()) { x_coordinates.Add(p.X); } return x_coordinates; } public List&amp;lt;double&amp;gt; getYs() { List&amp;lt;double&amp;gt; y_coordinates = new List&amp;lt;double&amp;gt;(); foreach (PointF p in this.getPath()) { y_coordinates.Add(p.Y); } return y_coordinates; } public List&amp;lt;PointF&amp;gt; getPath() { return this.path; } public void setPath(List&amp;lt;PointF&amp;gt; path) { this.path = path; } }  ]]></content:encoded>
    </item>
    <item>
      <title>8_R</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_6/8r/</link>
      <pubDate>Thu, 28 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_6/8r/</guid>
      <description>8_R assignament Request Do a research about the following topics:
  The law of large numbers LLN, the various definitions of convergence
  The convergence of the Binomial to the normal and Poisson distributions
  The central limit theorem [in anticipation of a topic we will study later]
  The Low of large numbers In probability theory, the law of large numbers (LLN) is a theorem that describes the result of performing the same experiment a large number of times.</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[8_R assignament Request Do a research about the following topics:
  The law of large numbers LLN, the various definitions of convergence
  The convergence of the Binomial to the normal and Poisson distributions
  The central limit theorem [in anticipation of a topic we will study later]
  The Low of large numbers In probability theory, the law of large numbers (LLN) is a theorem that describes the result of performing the same experiment a large number of times. According to the law, the average of the results obtained from a large number of trials should be close to the expected value and will tend to become closer to the expected value as more trials are performed. There is two main forms of this law a weak and a strong one:
Weak The weak law of large numbers (also called Khinchin&amp;rsquo;s law) states that the sample average converges in probability towards the expected value [1].
We have largly tested this with our work on the bernulli trials when we have see drowing the histograms that the frequencies tend to the probability the much more n is larger. Interpreting this result, the weak law states that for any nonzero margin specified (ε), no matter how small, with a sufficiently large sample there will be a very high probability that the average of the observations will be close to the expected value; that is, within the margin.
Uniform law of large numbers Suppose f(x,θ) is some function defined for θ ∈ Θ, and continuous in θ. Then for any fixed θ, the sequence {f(X1,θ), f(X2,θ), &amp;hellip;} will be a sequence of independent and identically distributed random variables, such that the sample mean of this sequence converges in probability to E[f(X,θ)]. This is the pointwise (in θ) convergence.[1]
Borel&amp;rsquo;s low of large number Named after Emile Borel states that if an experiment is repated a large number of times,independently under identical conditions, then the proportion of times that any specified event occurs approximately equals the probability of the event&amp;rsquo;s occurrence on any particular trial; the larger the number of repetitions, the better the approximation tends to be. More precisely, if E denotes the event in question, p its probability of occurrence, and Nn(E) the number of times E occurs in the first n trials, then with probability one:
Nn(E)/N &amp;ndash;&amp;gt; p as n→∞
Strong The strong law of large numbers (also called Kolmogorov&amp;rsquo;s law) states that the sample average converges almost surely to the expected value,(with almost sureley we mean with probability 1)
The convergence of the Binomial to the normal and Poisson dsistributions If n→∞ and p→0 while np approaches some positive number λ, then the binomial distribution approaches a Poisson distribution with expected value λ.
If n→∞ as p stays fixed, and X∼Binomial(n,p) then the distribution of (X−np)/√np(1-p) approaches the standard normal distribution, i.e. the normal distribution with expected value 0 and standard deviation 1.
The central limit theorem The central limit theorem state that when indipendent random variable are summed up their normalized sum tend to a normal distributions(beell curve) even when the original variable are not distribuited normaly(Lyapunov CLT[2]).
In other words we could say that given a poupulation and calculated the mean and the standard deviation,if we take a sufficiently large random samples from the population with replacement, then the distribution of the sample means will be approximately normally distributed and that this will hold true regardless of whether the source population is normal or skewed, provided the sample size is sufficiently large. In this week app this is particularly spottable in the realtive case,in fact when n increases,the convergence become centralIn this weak app this is particularly spottable eein the realtive case,in fact when n increases,the convergence become central.
[1]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://en.wikipedia.org/wiki/Law_of_large_numbers#Weak_law&amp;quot; [2]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://en.wikipedia.org/wiki/Central_limit_theorem#Lyapunov_CLT&amp;quot;
]]></content:encoded>
    </item>
  </channel>
</rss>
