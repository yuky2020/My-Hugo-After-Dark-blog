<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>Week 4 HW on Matteo Bianchi personal site and blog</title>
    <link>https://www.matteobianchi.eu/statistics-posts/week_4/</link>
    <description>Recent content in Week 4 HW on Matteo Bianchi personal site and blog</description>
    <image>
      <title>Week 4 HW on Matteo Bianchi personal site and blog</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_4/</link>
      <url>https://source.unsplash.com/collection/983219/2000x1322</url>
    </image>
    <ttl>1440</ttl>
    <generator>After Dark 9.2.3 (Hugo 0.80.0)</generator>
    <language>en-US</language>
    <lastBuildDate>Thu, 18 Nov 2021 23:46:40 UT</lastBuildDate>
    <atom:link href="https://www.matteobianchi.eu/statistics-posts/week_4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>4_RA</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_4/4ra/</link>
      <pubDate>Mon, 18 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_4/4ra/</guid>
      <description>4_RA assignament Request Do a personal research about the real world window to viewport transformation, and note separately the formulas and code which can be useful for your present and future applications.
real world to viewport When we want to drow a chart in .net we need to address the problem of rappresenting points inside a pictureBox(often inside a rectangle), for do this we need to operate some trasformation, we can do this one by one, or create a trasformation matrix and use this on every point.</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[4_RA assignament Request Do a personal research about the real world window to viewport transformation, and note separately the formulas and code which can be useful for your present and future applications.
real world to viewport When we want to drow a chart in .net we need to address the problem of rappresenting points inside a pictureBox(often inside a rectangle), for do this we need to operate some trasformation, we can do this one by one, or create a trasformation matrix and use this on every point. The matrix is for sure more rapid,and functional,so let&amp;rsquo;s look in depth how it works:
Traformation Matrix //Frist we need to create a matrix Matrix m = new Matrix(); //----- // then we need to prepare the needed trasformation m.Translate(-(int)minX_Window,-(int)minY_Window,MatrixOrder.Append); m.Scale( (int)(viewPort.Width / (maxX_Window - minX_Window)),(int)(-viewPort.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m.Translate(viewPort.Left, viewPort.Top &#43; viewPort.Height, MatrixOrder.Append); // we apply the trasformation to the array of points that we need in the graphics m.TransformPoints(myPoints ); // in the end we can write the point to the graphics (THIS IS AN EXAMPLE FROM MY IMPLEMENTATION)  foreach(PointF punto in myPoints) { if (myPointsreal[i].X &amp;lt;= maxX_Window &amp;amp;&amp;amp; myPointsreal[i].Y &amp;lt;= maxY_Window) { g.FillEllipse(Brushes.Black, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); g.DrawString(myPointsreal[i].ToString(), new Font(&amp;#34;Arial&amp;#34;, 10), Brushes.Black,(int)(punto.X), (int)(punto.Y)); g.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(punto.X - 2), (int)(viewPort.Y &#43; viewPort.Height - 2)), new Size(4, 4))); g.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(viewPort.X), (int)(int)(punto.Y - 2)), new Size(4, 4))); } }  ]]></content:encoded>
    </item>
    <item>
      <title>5_R</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_4/5r/</link>
      <pubDate>Mon, 18 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_4/5r/</guid>
      <description>5_R assignament Request Explain a possibly unified conceptual framework to obtain all most common measures of central tendency and of dispersion using the concept of distance (or &amp;ldquo;premetric&amp;rdquo;, or similarity in general). Discuss why it is useful to discuss these concepts introducing the notion of distance. Finally, point out the difference between the mathematical definition of &amp;ldquo;distance&amp;rdquo; and the properties of the &amp;ldquo;premetrics&amp;rdquo; useful in statistics, pointing out trhe most important distances, indexes and similarity measures used in statistics, data analysis and machine learning (such as for instance; Mahalanobis distance, Euclidean distance, Minkowski distance, Manhattan distance, Hamming distance, Cosine distance, Chebishev distance, Jaccard index, Haversine distance, Sørensen-Dice index, etc.</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[5_R assignament Request Explain a possibly unified conceptual framework to obtain all most common measures of central tendency and of dispersion using the concept of distance (or &amp;ldquo;premetric&amp;rdquo;, or similarity in general). Discuss why it is useful to discuss these concepts introducing the notion of distance. Finally, point out the difference between the mathematical definition of &amp;ldquo;distance&amp;rdquo; and the properties of the &amp;ldquo;premetrics&amp;rdquo; useful in statistics, pointing out trhe most important distances, indexes and similarity measures used in statistics, data analysis and machine learning (such as for instance; Mahalanobis distance, Euclidean distance, Minkowski distance, Manhattan distance, Hamming distance, Cosine distance, Chebishev distance, Jaccard index, Haversine distance, Sørensen-Dice index, etc.).
Central tendency In statistics, a central tendency (or measure of central tendency) is a typical or central value for a probability distribution [2] also called a center or location of the distribution. nevertheless measures of central tendency are often called averages.
common measures of central tendency are the arithmetic mean, the median, and the mode. A middle tendency can be calculated for either a finite set of values or for a theoretical distribution, such as the normal distribution. Occasionally authors use central tendency to denote “the tendency of quantitative data to cluster around some central value.” The central tendency of a distribution is typically contrasted with its dispersion or variability; dispersion and central tendency are the often characterized properties of distributions. Analysis may judge whether data has a strong or a weak central tendency based on its dispersion. In statistics, probability theory, and information theory, a statistical distance quantifies the distance between two statistical objects, which can be two random variables, or two probability distributions or samples, or the distance can be between an individual sample point and a population or a wider sample of points.[3]
Arithmetic Mean: In mathematics and statistics, the arithmetic mean or simply the mean or the average (when the context is clear), is the sum of a collection of numbers divided by the count of numbers in the collection. For sure we can also use is online implementation fon fast computation but the meaning remain the same,[2]
Median: the median of a population is any value such that at most half of the population is less than the proposed median and at most half is greater than the proposed median.Medians may not be unique. If each set contains less than half the population, then some of the population is exactly equal to the unique median[4].
The median is well-defined for any ordered (one-dimensional) data, and is independent of any distance metric. The median can thus be applied to classes which are ranked but not numerical (e.g. working out a median grade when students are graded from A to F), although the result might be halfway between classes if there is an even number of cases.
Mode: The mode of a sample is the element that occurs most often in the collection. For example, the mode of the sample [1,3, 3, 3, 3, 5, 7, 7, 20, 30, 50 is 3. Given the list of data [1, 1, 2, 4, 4] the mode is not unique – the dataset may be said to be bimodal, while a set with more than two modes may be described as multimodal.Usualy in the bimodal case we take as the mode the avreage of the two mode if is possible, infact unlike mean and median, the concept of mode also makes sense for “nominal data” (i.e., not consisting of numerical values in the case of mean, or even of ordered values in the case of median).
Dispersion: percentiles and standard deviations Several measures of dispersion include range,standard deviations and quantiles, in general we can say that dispersion is the size of distribution of values in a data set.
Based on the mean, the standard deviation It’s a measure of how far each observed value is from the mean in a data set usualy deviation will be represented by the lower case Greek letter sigma (σ). Can be used when the distribution of data is rappresentable as a normal distribution, and is used to determine whether a particular data point is in standard or unusual range. The more devieted a data point is from the mean, the more “unusual” that data point is. A low value for the standard deviation means that most of the data are around the mean,while a high value means that the data are spread over a wider range of values.[7]
Quantiles Quantiles can be applied to any continuous data set, a quantile divides a data set in continuos distribution made of equal proportions and represents the proportion of data at any point; the most used quantiles are:
 Quartiles: dataset diveded in 4 quarters. Quintiles: dataset is divided in 5 Percentiles: dataset is divided into 100 we can for sure also extract the median from the quantiles for ex: the 50th percentile and the 3 quintiles is the median.  Distance Distance is a numerical measurement of how far apart objects or points are. In mathematics, a distance function or metric is a generalization of the concept of physical distance; it is a way of describing what it means for elements of some space to be “close to”, or “far away from” each other.[6]
In the Euclidean space Rn, the distance between two points is usually given by the Euclidean distance (2-norm distance); but Euclidean distance could be extended also to n-space, and become usefull also in other field as ML and biometrics(Algorithm like HOG: my implementation); the infinity version is called also Chebyshev distance. Other distances, based on other norms, are sometimes usefull like the Minkowski distance(of various order p (p-norm distance))
[1] &amp;ldquo;https://en.wikipedia.org/wiki/Arithmetic_mean &amp;quot; [2]&amp;ldquo;https://en.wikipedia.org/wiki/Statistical_distance &amp;quot; [3]&amp;ldquo;https://en.wikipedia.org/wiki/Central_tendency &amp;quot; [4]&amp;ldquo;https://en.wikipedia.org/wiki/Median &amp;quot; [5]&amp;ldquo;https://en.wikipedia.org/wiki/Mode_(statistics) &amp;quot; [6]&amp;ldquo;https://it.wikipedia.org/wiki/Distanza_(matematica) &amp;quot;
]]></content:encoded>
    </item>
    <item>
      <title>6_A</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_4/6a/</link>
      <pubDate>Mon, 18 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_4/6a/</guid>
      <description>6_A assignament Request Prepare separately the following charts: 1) Scatterplot, 2) Histogram/Column chart [in the histogram, within each class interval, draw also a vertical colored line where lies the true mean of the observations falling in that class] and 3) Contingency table, using the graphics object and its methods (Drawstring(), MeasureString(), DrawLine(), etc). Use them to represent 2 numerical variables that you select from a CSV file. In particular, in the same picture box, you will make at least 2 separate charts: 1 dynamic rectangle will contain the contingency table, and 1 rectangle (chart) will contain the scatterplot, with the histograms/column charts and rug plots drawn respectively near the two axis (and oriented accordingly)</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[6_A assignament Request Prepare separately the following charts: 1) Scatterplot, 2) Histogram/Column chart [in the histogram, within each class interval, draw also a vertical colored line where lies the true mean of the observations falling in that class] and 3) Contingency table, using the graphics object and its methods (Drawstring(), MeasureString(), DrawLine(), etc). Use them to represent 2 numerical variables that you select from a CSV file. In particular, in the same picture box, you will make at least 2 separate charts: 1 dynamic rectangle will contain the contingency table, and 1 rectangle (chart) will contain the scatterplot, with the histograms/column charts and rug plots drawn respectively near the two axis (and oriented accordingly)
My Solution   Code in C#
Class Main Form in C# public partial class Bivarianteform : Form { public Bivarianteform() { InitializeComponent(); b = new Bitmap(755,681); g = Graphics.FromImage(b); contb = new Bitmap(739,668); g2 = Graphics.FromImage(contb); } Dictionary&amp;lt;int, ElementoDisribuzione&amp;gt; csvContent = new Dictionary&amp;lt;int, ElementoDisribuzione&amp;gt;(); Distribuzione distr = new Distribuzione(); MediaCalOnline medie = new MediaCalOnline(); String[,] bivariantMatrix; List&amp;lt;String&amp;gt; attributename = new List&amp;lt;string&amp;gt;(); List&amp;lt;String&amp;gt; bivariante = new List&amp;lt;string&amp;gt;();//per ora poi diventera n variante;  Bitmap b; Bitmap contb; Graphics g2; Graphics g; Matrix m = new Matrix(); Matrix m2 = new Matrix(); Matrix m3 = new Matrix(); int nr, nc; //Distributions  SortedDictionary&amp;lt;Tuple&amp;lt;double, double&amp;gt;, int&amp;gt; firstdistr; SortedDictionary&amp;lt;Tuple&amp;lt;double, double&amp;gt;, int&amp;gt; seconddistr; bool movable = false; bool resiable = false; // movable view port  int contgleft = 0; int contgtop = 50; int contgwid = 300; int contgheight = 400; int mouseDeltax=0; int mouseDeltay=0; Rectangle viewPortcontig=new Rectangle(0,50, 300, 400); private void button1_Click(object sender, EventArgs e) { var filePath = string.Empty; openFileDialog1.InitialDirectory = &amp;#34;c:\\&amp;#34;; openFileDialog1.Filter = &amp;#34;csv files (*.csv)|*.csv|All files (*.*)|*.*&amp;#34;; openFileDialog1.FilterIndex = 2; openFileDialog1.RestoreDirectory = true; if (openFileDialog1.ShowDialog() == DialogResult.OK) { //Get the path of specified file  filePath = openFileDialog1.FileName; //Read the contents of the file into a stream  using (TextFieldParser csvParser = new TextFieldParser(filePath)) { csvParser.CommentTokens = new string[] { &amp;#34;#&amp;#34; }; csvParser.SetDelimiters(new string[] { &amp;#34;,&amp;#34; }); csvParser.HasFieldsEnclosedInQuotes = true; // Save the row with the column names  string[] fieldsNames = csvParser.ReadFields(); attributename.AddRange(fieldsNames); int i = 0; while (!csvParser.EndOfData) { // Read current line fields, pointer moves to the next line.  string[] fields = csvParser.ReadFields(); ElementoDisribuzione elem = new ElementoDisribuzione(fields[0]); int j = 0; foreach (String field in fields) { if (!String.IsNullOrEmpty(field)) { double tmp; if (Double.TryParse(field, out tmp)) { elem.setVariable(fieldsNames[j], new Tuple&amp;lt;Object, Type&amp;gt;(tmp, tmp.GetType())); medie.addAttribute(fieldsNames[j], tmp); } else elem.setVariable(fieldsNames[j], new Tuple&amp;lt;Object, Type&amp;gt;(field, field.GetType())); } j&#43;&#43;; } csvContent.Add(i, elem); distr.addElementoDef(elem); i&#43;&#43;; } } button2.Visible = true; } } private void button2_Click(object sender, EventArgs e) { ; foreach (var elem in attributename) contextMenuStrip1.Items.Add(elem); contextMenuStrip1.Visible = true; } private void contextMenuStrip1_Opening(object sender, CancelEventArgs e) { } private void contextMenuStrip1_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { double media = 0; double stdVariation; List&amp;lt;Double&amp;gt; values=new List&amp;lt;double&amp;gt;(0); medie.getMedia(e.ClickedItem.Text, out media); //se la media è diversa da zero sono sicuro che è double  if (media != 0) { Tuple&amp;lt;Object, Type&amp;gt; tmp; foreach (var elm in csvContent.Values) { elm.getVariable(e.ClickedItem.Text, out tmp); values.Add((double)tmp.Item1); } medie.getStandardDeviation(e.ClickedItem.Text, values,out stdVariation); distr.getdistribuzioneN(e.ClickedItem.Text, out firstdistr); } else stdVariation = 0; bivariante.Add(e.ClickedItem.Text); button2.Visible = false; foreach (var elem in attributename) contextMenuStrip2.Items.Add(elem); contextMenuStrip2.Visible = true; } private void contextMenuStrip2_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { double media2 = 0; double stdVariation; List&amp;lt;Double&amp;gt; values = new List&amp;lt;double&amp;gt;(0); bool isDouble = false; medie.getMedia(e.ClickedItem.Text, out media2); if (media2 != 0) { isDouble = true; Tuple&amp;lt;Object, Type&amp;gt; tmp; foreach (var elm in csvContent.Values) { elm.getVariable(e.ClickedItem.Text, out tmp); values.Add((double)tmp.Item1); } medie.getStandardDeviation(e.ClickedItem.Text, values, out stdVariation); distr.getdistribuzioneN(e.ClickedItem.Text, out seconddistr); } else stdVariation = 0; bivariante.Add(e.ClickedItem.Text); bivariantMatrix = distr.getbivariantmatrix(bivariante, csvContent.Values, out nr, out nc); this.button3.Visible = true; } private void button3_Click(object sender, EventArgs e) { creaGrafici(g); } private void creaGrafici(Graphics g) { //viewport scatterport  Rectangle viewPort = new Rectangle(300, 50, 400,400); int i = 0; // window  double minX_Window = 0; double maxX_Window = 400; double minY_Window = 0; double maxY_Window = 400; g.Clear(Color.DarkGray); g.FillRectangle(Brushes.White , viewPort); g.DrawLine(new Pen(Color.Black,2), viewPort.X,viewPort.Y ,viewPort.X, (viewPort.Y &#43;viewPort.Height)); g.DrawLine(new Pen(Color.Black,2), viewPort.X,(viewPort.Y &#43; viewPort.Height),(viewPort.X&#43;viewPort.Width), (viewPort.Y &#43; viewPort.Height)); m.Translate(-(int)minX_Window,-(int)minY_Window,MatrixOrder.Append); m.Scale( (int)(viewPort.Width / (maxX_Window - minX_Window)),(int)(-viewPort.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m.Translate(viewPort.Left, viewPort.Top &#43; viewPort.Height, MatrixOrder.Append); List&amp;lt;PointF&amp;gt; points = new List&amp;lt;PointF&amp;gt;(); foreach(var elem in csvContent) { Tuple&amp;lt;Object,Type &amp;gt;a, b; float x,y; elem.Value.getVariable(bivariante.ElementAt(0), out a); elem.Value.getVariable(bivariante.ElementAt(1), out b); x = (float)(double)a.Item1; y = (float)(double)b.Item1; points.Add(new PointF(x, y)); } PointF[] myPoints = points.ToArray(); PointF[] myPointsreal = points.ToArray(); i = 0; m.TransformPoints(myPoints ); foreach(PointF punto in myPoints) { if (myPointsreal[i].X &amp;lt;= maxX_Window &amp;amp;&amp;amp; myPointsreal[i].Y &amp;lt;= maxY_Window) { g.FillEllipse(Brushes.Black, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); g.DrawString(myPointsreal[i].ToString(), new Font(&amp;#34;Arial&amp;#34;, 10), Brushes.Black,(int)(punto.X), (int)(punto.Y)); g.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(punto.X - 2), (int)(viewPort.Y &#43; viewPort.Height - 2)), new Size(4, 4))); g.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(viewPort.X), (int)(int)(punto.Y - 2)), new Size(4, 4))); } i&#43;&#43;; ; } //Column x chart viewport  Rectangle viewPort2 = new Rectangle(300, 450, 400, 100); g.FillRectangle(Brushes.White, viewPort2); g.DrawLine(new Pen(Color.Black, 2), viewPort2.X, viewPort2.Y, viewPort2.X, (viewPort2.Y &#43; viewPort2.Height)); g.DrawLine(new Pen(Color.Black, 2), viewPort2.X, (viewPort2.Y &#43; viewPort2.Height), (viewPort2.X &#43; viewPort2.Width), (viewPort2.Y &#43; viewPort2.Height)); m2.Translate(-(int)minX_Window, -(int)minY_Window, MatrixOrder.Append); m2.Scale((int)(viewPort2.Width / (maxX_Window - minX_Window)), (int)(-viewPort2.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m2.Translate(viewPort2.Left, viewPort2.Top &#43; viewPort2.Height, MatrixOrder.Append); List&amp;lt;PointF&amp;gt; distrF = new List&amp;lt;PointF&amp;gt;(); foreach(var point in firstdistr) { distrF.Add(new PointF((float)((point.Key.Item2 - point.Key.Item1)/2 &#43;point.Key.Item1), point.Value)); } PointF[] myPoints2 = distrF.ToArray(); PointF[] myPoints2real = distrF.ToArray(); i = 0; m2.TransformPoints(myPoints2); foreach (PointF punto in myPoints2) { if (myPoints2real[i].X &amp;lt;= maxX_Window &amp;amp;&amp;amp; myPoints2real[i].Y &amp;lt;= maxY_Window) g.FillRectangle(Brushes.DarkCyan, new Rectangle((int)punto.X,viewPort2.Top,viewPort2.Width/30, (int)myPoints2real[i].Y/10)); i&#43;&#43;; } //contingeny  Rectangle viewPort3 = new Rectangle(200, 50, 100, 400); g.FillRectangle(Brushes.White, viewPort3); g.DrawLine(new Pen(Color.Black, 2), viewPort3.X, viewPort3.Y, viewPort3.X, (viewPort3.Y &#43; viewPort3.Height)); g.DrawLine(new Pen(Color.Black, 2), viewPort3.X, (viewPort3.Y &#43; viewPort3.Height), (viewPort3.X &#43; viewPort3.Width), (viewPort3.Y &#43; viewPort3.Height)); m3.Translate(-(int)minX_Window, -(int)minY_Window, MatrixOrder.Append); m3.Scale((int)(viewPort3.Width / (maxX_Window - minX_Window)), (int)(-viewPort3.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m3.Translate(viewPort3.Left, viewPort3.Top &#43; viewPort3.Height, MatrixOrder.Append); List&amp;lt;PointF&amp;gt; distrS = new List&amp;lt;PointF&amp;gt;(); foreach (var point in seconddistr) { distrS.Add(new PointF(point.Value, (float)((point.Key.Item2 - point.Key.Item1) / 2 &#43; point.Key.Item1))); } PointF[] myPoints3 = distrS.ToArray(); PointF[] myPoints3real = distrS.ToArray(); i = 0; m3.TransformPoints(myPoints3); foreach (PointF punto in myPoints3) { if (myPoints3real[i].X &amp;lt;= maxX_Window &amp;amp;&amp;amp; myPoints3real[i].Y &amp;lt;= maxY_Window) g.FillRectangle(Brushes.DarkCyan, new Rectangle(viewPort3.Left, (int)punto.Y, (int)punto.X/10, viewPort3.Height/30)); i&#43;&#43;; } //contingency  createconting(g2, 0, 50,300,400); pictureBox1.Image = b; } private void createconting(Graphics g2, int dinamicleft, int dinamictop,int contgw,int contgh) { viewPortcontig.X = dinamicleft; viewPortcontig.Y = dinamictop; viewPortcontig.Width = contgw; viewPortcontig.Height = contgh; //viewPortcontig.Location= new Point(viewPortcontig.Location.X&#43;dinamicleft,viewPortcontig.Location.Y&#43;dinamictop);  g2.Clear(BackColor); g2.FillRectangle(Brushes.White, viewPortcontig); int j = 0; for (int i = 0; i &amp;lt;= nr; i&#43;&#43;) { for (j = 0; j &amp;lt;= nc; j&#43;&#43;) { Rectangle tmp = new Rectangle(viewPortcontig.Left &#43; (j * (viewPortcontig.Width / (nc &#43; 1))), viewPortcontig.Top &#43; (i * (viewPortcontig.Height / (nr &#43; 1))), viewPortcontig.Width / (nc &#43; 1), viewPortcontig.Height / (nr &#43; 1)); g2.DrawRectangle(new Pen(Color.Black, 2), tmp); g2.DrawString(bivariantMatrix[i, j], new Font(&amp;#34;Arial&amp;#34;, 6), Brushes.Black, tmp); } } pictureBox2.Image = contb ; } private void pictureBox2_MouseDown(object sender, MouseEventArgs e) { if ( (e.Location.Y&amp;gt;=viewPortcontig.Top &amp;amp;&amp;amp;e.Location.Y &amp;lt;= (viewPortcontig.Top&#43;viewPortcontig.Height))&amp;amp;&amp;amp;(e.Location.X &amp;gt;= viewPortcontig.Left &amp;amp;&amp;amp; e.Location.X &amp;lt;= (viewPortcontig.Left &#43; viewPortcontig.Width))) { if (e.Button == MouseButtons.Left) movable = true; if (e.Button == MouseButtons.Right) resiable = true; mouseDeltax = e.Location.X; mouseDeltay = e.Location.Y; } } private void pictureBox2_MouseLeave(object sender, EventArgs e) { resiable = false; movable = false; } private void pictureBox2_MouseMove(object sender, MouseEventArgs e) { if (movable == true) { contgleft = e.Location.X; contgtop = e.Location.Y; if (contgleft &amp;lt;= 0) contgleft = 0; if (contgtop &amp;lt;= 20) contgtop = 20; } if (resiable == true) { mouseDeltax = -mouseDeltax &#43; e.Location.X ; mouseDeltay = -mouseDeltay &#43; e.Location.Y; contgwid &#43;= mouseDeltax/40; contgheight &#43;= mouseDeltay/40; } createconting(g2, contgleft, contgtop,contgwid,contgheight); } private void pictureBox2_MouseUp(object sender, MouseEventArgs e) { resiable = false; movable = false; } private void pictureBox1_Click(object sender, EventArgs e) { } } }  ]]></content:encoded>
    </item>
  </channel>
</rss>
