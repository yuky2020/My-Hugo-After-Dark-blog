<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>Week 7 HW on Matteo Bianchi personal site and blog</title>
    <link>https://www.matteobianchi.eu/statistics-posts/week_7/</link>
    <description>Recent content in Week 7 HW on Matteo Bianchi personal site and blog</description>
    <image>
      <title>Week 7 HW on Matteo Bianchi personal site and blog</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_7/</link>
      <url>https://source.unsplash.com/collection/983219/2000x1322</url>
    </image>
    <ttl>1440</ttl>
    <generator>After Dark 9.2.3 (Hugo 0.80.0)</generator>
    <language>en-US</language>
    <lastBuildDate>Fri, 12 Nov 2021 18:15:18 UT</lastBuildDate>
    <atom:link href="https://www.matteobianchi.eu/statistics-posts/week_7/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>7_RA</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_7/7ra/</link>
      <pubDate>Thu, 28 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_7/7ra/</guid>
      <description>7_RA assignament Request Do a research about the random walk process and its properties. Compare your finding with your applications drawing your personal conclusions. Explain based on your exercise the beaviour of the distribution of the stochastic process (check out &amp;ldquo;Donsker&amp;rsquo;s invariance principle&amp;rdquo;). What are, in particular, its mean and variance at time n ?
Random walk process In mathematics, a random walk is a mathematical object, known as a stochastic or random process, that describes a path that consists of a succession of random steps on some mathematical space such as the integers.</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[7_RA assignament Request Do a research about the random walk process and its properties. Compare your finding with your applications drawing your personal conclusions. Explain based on your exercise the beaviour of the distribution of the stochastic process (check out &amp;ldquo;Donsker&amp;rsquo;s invariance principle&amp;rdquo;). What are, in particular, its mean and variance at time n ?
Random walk process In mathematics, a random walk is a mathematical object, known as a stochastic or random process, that describes a path that consists of a succession of random steps on some mathematical space such as the integers.
Integer random walk (1,-1) An elementary example of a random walk is the random walk on the integer number line,Z , which starts at 0 and at each step moves &#43;1 or −1 with equal probability.[1]
Other example Other examples include the path traced by a molecule as it travels in a liquid or a gas (see Brownian motion), the search path of a foraging animal, the price of a fluctuating stock and the financial status of a gambler: all can be approximated by random walk models, even though they may not be truly random in reality.[1]
In the 9A2 We have used the integer random walk in -1 1 and compared it with a standard normal ditribution (both moltiplicated by a fixed factor sqrt(1/n)) and with this comparison, by the histograms that rappresent the empiricals frequencies distribution,we could see that the two graphs are quite similar both with mean 0 and variance 1, this is in line with what stated by the Donsker&amp;rsquo;s invariance principle(functional central limit theorem)[2]
Functional central limit theorem the functional central limit theorem), named after Monroe D. Donsker, is a functional extension of the central limit theorem, state that: As random variables taking values in the Skorokhod space D[0,1], the random function W^n converges in distribution to a standard Brownian motion
W:=(W(t)) with t in [0,1] and n-&amp;gt;∞ [1]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://en.wikipedia.org/wiki/Random_walk&amp;quot; [2]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://en.wikipedia.org/wiki/Donsker%27s_theorem&amp;quot;
]]></content:encoded>
    </item>
    <item>
      <title>9_A</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_7/9a/</link>
      <pubDate>Thu, 28 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_7/9a/</guid>
      <description>9_A1 assignament Request Create a simulation with graphics to convince yourself of the pointwise convergence of the empirical CDF to the theoretical distribution (Glivenko-Cantelli theorem). Use a simple random variable of your chooice for such a demonstration.
My Solution   Code in C#
Methods for calculate empirical CDS in C# public List&amp;lt;PointF&amp;gt; CDFtoViewport(Rectangle viewPort,int n) { List&amp;lt;PointF&amp;gt; cdfs=new List&amp;lt;PointF&amp;gt;(); List&amp;lt;int&amp;gt; values=new List&amp;lt;int&amp;gt;(); for (int i=0; i &amp;lt; n; i&#43;&#43;) { values.</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[9_A1 assignament Request Create a simulation with graphics to convince yourself of the pointwise convergence of the empirical CDF to the theoretical distribution (Glivenko-Cantelli theorem). Use a simple random variable of your chooice for such a demonstration.
My Solution   Code in C#
Methods for calculate empirical CDS in C# public List&amp;lt;PointF&amp;gt; CDFtoViewport(Rectangle viewPort,int n) { List&amp;lt;PointF&amp;gt; cdfs=new List&amp;lt;PointF&amp;gt;(); List&amp;lt;int&amp;gt; values=new List&amp;lt;int&amp;gt;(); for (int i=0; i &amp;lt; n; i&#43;&#43;) { values.Add(R.Next(149, 220)); } float tmpy = 0; float tmpx = -1; for (int i = 150; i &amp;lt;= 220; i = i &#43; 5) { tmpy = 0; tmpx = tmpx &#43; 1 ; foreach (int p in values) { if (p &amp;lt; i) tmpy&#43;&#43;; //empirical CDF  } cdfs.Add(new PointF(tmpx, tmpy/n)); } PointF[] viewPortArraycdf = cdfs.ToArray(); this.m2.TransformPoints(viewPortArraycdf); return(viewPortArraycdf.ToList()); }  Method to draw both empirical and theorical rapresentation private void disegnaCDFPaths(List&amp;lt;PointF&amp;gt; viewPortCDF) { Pen pen = new Pen(Color.Red); Pen pen2 = new Pen(Color.Green); //empirical cdf  for (int j = 1; j &amp;lt; viewPortCDF.Count; j&#43;&#43;) { g2.DrawLine(pen, (float)viewPortCDF[j-1].X, (float)viewPortCDF[j-1].Y, (float)viewPortCDF[j].X, (float)viewPortCDF[j].Y); g2.DrawEllipse(pen, new Rectangle((int)viewPortCDF[j].X, (int)viewPortCDF[j].Y, 4,4)); } //theorical cdf  g2.DrawLine(pen2,(viewPort.Left&#43;viewPort.Width), viewPort.Top, viewPort.Left, viewPort.Top&#43;viewPort.Height); }  9_A2 assignament Request Generate sample paths of jump processes which at each time considered t = 1, &amp;hellip;, n perform jumps computed as:
  σ sqrt(1/n) R(t) where R(t) is a [-1,1] Rademacher random variable (https://en.wikipedia.org/wiki/Rademacher_distribution).
  σ sqrt(1/n) * Z(t), where Z(t) is a N(0,1) random variable (https://en.wikipedia.org/wiki/Normal_distribution)
  and see what happens as n (simulation parameter) becomes larger.
[As before, at time n (last time) and one other chosen inner time 1&amp;lt;j&amp;lt;n (j is a program parameter) create and represent with histogram the distribution of the process ]
My Solution   Code in C#
Interface Pathfinder in C# interface Pathfinder { abstract public List&amp;lt;Strade&amp;gt; Get_paths(); }  Class Rademacher Pathfinder in C# public class RademacherPathfinder : Pathfinder { int m; //number of paths  int n; //number of points  double p; //probability  public List&amp;lt;Strade&amp;gt; paths = new List&amp;lt;Strade&amp;gt;(); private Random R; public RademacherPathfinder(int n, int m) { this.m = n; this.n = m; this.p = 0.5; this.R = new Random(); for (int i=0; i &amp;lt; m; i&#43;&#43;) { paths.Add(new Strade(createRademacherList())); } } private int rademacher_Result(double p) { double random_outcome = R.NextDouble(); if (random_outcome &amp;lt; p) return 1; else if (random_outcome == p) return 0; return -1; } private List&amp;lt;double&amp;gt; createRademacherList() { List&amp;lt;double&amp;gt; rademacher = new List&amp;lt;double&amp;gt;(); for (int i = 0; i &amp;lt; n; i&#43;&#43;) { rademacher.Add(rademacher_Result(p)); } return rademacher; } public List&amp;lt;Strade&amp;gt; Get_paths() { return this.paths; } }  Class Normal Pathfinder in C# public class NormalPathfinder: Pathfinder { int m; //number of paths  int n; //number of points  double p; //probability  public List&amp;lt;Strade&amp;gt; paths = new List&amp;lt;Strade&amp;gt;(); private Random R; public NormalPathfinder(int n, int m) { this.m = n; this.n = m; this.p = 0.5; this.R = new Random(); for (int i=0; i &amp;lt; m; i&#43;&#43;) { paths.Add(new Strade(createNormalList())); } } private double normal_Result(double p) { double random_outcome = R.NextDouble(); double normal_distrbAtOut; double v = R.NextDouble(); //create a value between 1 and -1  random_outcome = random_outcome * 2 - 1; //get the standard normal for that point  normal_distrbAtOut= Math.Pow(Math.E, (Math.Pow(-random_outcome, 2) / 2))/Math.Sqrt(2*Math.PI) ; //then use the other generated random  if (v &amp;lt; normal_distrbAtOut) return random_outcome; else return 0; } private List&amp;lt;double&amp;gt; createNormalList() { List&amp;lt;double&amp;gt; normal = new List&amp;lt;double&amp;gt;(); for (int i = 0; i &amp;lt; n; i&#43;&#43;) { normal.Add(normal_Result(p)); } return normal; } public List&amp;lt;Strade&amp;gt; Get_paths() { return this.paths; } }  Disegna grafici class public class DisegnaGrafici { public Bitmap bitmap; public Graphics g2; public PictureBox pictureBox; private int SCALE = 4; private Random R = new Random(); public List&amp;lt;Strade&amp;gt; viewPortPaths; public List&amp;lt;Strade&amp;gt; viewPortAbsolute; private Rectangle viewPort; int n; Matrix m1; Matrix m2; Pathfinder distrubution; public DisegnaGrafici(int m, int n, int j, Graphics graphics, double epsilon, Rectangle vPort, int dinamicleft, int dinamictop, int contgw, int contgh, TextBox boxassfreq, TextBox boxrelfreq, bool is_abs,bool is_norml) { this.g2 = graphics; this.viewPort = vPort; this.viewPort.X = dinamicleft; this.viewPort.Y = dinamictop; this.viewPort.Width = contgw; this.viewPort.Height = contgh; this.n = n; this.m1 = new Matrix(); this.m2 = new Matrix(); g2.Clear(Color.Transparent); g2.FillRectangle(Brushes.Transparent, this.viewPort); g2.DrawRectangle(new Pen(Color.Black), this.viewPort); //genero la marice per le trasformazioni  m1.Reset(); m1.Translate((float)-0, -(float)0, MatrixOrder.Append); m1.Scale((float)(viewPort.Width /m ), (float)(-viewPort.Height /1), MatrixOrder.Append); m1.Translate(viewPort.Left, viewPort.Top &#43; viewPort.Height, MatrixOrder.Append); //Matrix for the cdf  m2.Reset(); m2.Translate((float)-0, -(float)0, MatrixOrder.Append); m2.Scale((float)(viewPort.Width /14), (float)(-viewPort.Height / 1), MatrixOrder.Append); m2.Translate(viewPort.Left, viewPort.Top &#43; viewPort.Height, MatrixOrder.Append); //genero le &amp;#34;strade&amp;#34;  if (is_norml == false) distrubution = new RademacherPathfinder(n, m); else distrubution = new NormalPathfinder(n, m); //disegno i vari path convertendoli per il viewport  if (is_abs) disegnaCDFPaths(CDFtoViewport(viewPort,n)); else { disegnaPaths(fromPathstoViewport(distrubution.Get_paths(), viewPort)); disegnaHistogramma(viewPort, getDistribution(distrubution.Get_paths(), m / SCALE, j), n, j); disegnaHistogramma(viewPort, getDistribution(distrubution.Get_paths(), m / SCALE, n), n, n); } getAbsoluteFrequencies(distrubution.Get_paths(), n, m, epsilon, boxassfreq, boxrelfreq); } private void disegnaCDFPaths(List&amp;lt;PointF&amp;gt; viewPortCDF) { Pen pen = new Pen(Color.Red); Pen pen2 = new Pen(Color.Green); //empirical cdf  for (int j = 1; j &amp;lt; viewPortCDF.Count; j&#43;&#43;) { g2.DrawLine(pen, (float)viewPortCDF[j-1].X, (float)viewPortCDF[j-1].Y, (float)viewPortCDF[j].X, (float)viewPortCDF[j].Y); g2.DrawEllipse(pen, new Rectangle((int)viewPortCDF[j].X, (int)viewPortCDF[j].Y, 4,4)); } //theorical cdf  g2.DrawLine(pen2,(viewPort.Left&#43;viewPort.Width), viewPort.Top, viewPort.Left, viewPort.Top&#43;viewPort.Height); } public List&amp;lt;PointF&amp;gt; CDFtoViewport(Rectangle viewPort,int n) { List&amp;lt;PointF&amp;gt; cdfs=new List&amp;lt;PointF&amp;gt;(); List&amp;lt;int&amp;gt; values=new List&amp;lt;int&amp;gt;(); for (int i=0; i &amp;lt; n; i&#43;&#43;) { values.Add(R.Next(149, 220)); } float tmpy = 0; float tmpx = -1; for (int i = 150; i &amp;lt;= 220; i = i &#43; 5) { tmpy = 0; tmpx = tmpx &#43; 1 ; foreach (int p in values) { if (p &amp;lt; i) tmpy&#43;&#43;; //empirical CDF  } cdfs.Add(new PointF(tmpx, tmpy/n)); } PointF[] viewPortArraycdf = cdfs.ToArray(); this.m2.TransformPoints(viewPortArraycdf); return(viewPortArraycdf.ToList()); } public void getAbsoluteFrequencies(List&amp;lt;Strade&amp;gt; paths, int n, int m, double epsilon, TextBox boxassfreq, TextBox boxrelfreq) { double p=0.5 ; Intervalli p_neighbourhood = new Intervalli(p - epsilon, p &#43; epsilon); int absolute_frequency = 0; double relative_frequency = 0; foreach (Strade path in paths) { for (int i = 0; i &amp;lt; path.getPath().Count; i&#43;&#43;) { if ( (path.getPath()[i].X == n) &amp;amp;&amp;amp; (path.getPath()[i].Y &amp;gt;= p_neighbourhood.LowerBound) &amp;amp;&amp;amp; (path.getPath()[i].Y &amp;lt; p_neighbourhood.UpperBound) ) { absolute_frequency&#43;&#43;; } } } relative_frequency = (double)absolute_frequency / (double)m; boxassfreq.Text = absolute_frequency.ToString(); boxrelfreq.Text = relative_frequency * 100 &#43; &amp;#34;%&amp;#34;; } public void disegnaPaths(List&amp;lt;Strade&amp;gt; viewPortPaths) { for (int i = 0; i &amp;lt; viewPortPaths.Count; i&#43;&#43;) { Pen pen = new Pen(Color.FromArgb(R.Next(0, 255), R.Next(0, 255), R.Next(0, 255))); for (int j = 0; j &amp;lt; viewPortPaths[i].getPath().Count - 1; j&#43;&#43;) { g2.DrawLine(pen, (float)viewPortPaths[i].getPath()[j].X, (float)viewPortPaths[i].getPath()[j].Y, (float)viewPortPaths[i].getPath()[j &#43; 1].X, (float)viewPortPaths[i].getPath()[j &#43; 1].Y); } } } public void disegnaHistogramma(Rectangle viewPort, List&amp;lt;Intervalli&amp;gt; intervals, int n, int j) { for (int i = 0; i &amp;lt; intervals.Count; i&#43;&#43;) { int x, y; int width, height; // in this case on the fly trasformation is way faster  x = (int)(this.viewPort.Left &#43; this.viewPort.Width * (j) /n); y = (int)(viewPort.Top &#43; viewPort.Height/2 * ((100 - (intervals[i].UpperBound) * 100) / 100)); width = intervals[i].Counter; height = viewPort.Height / intervals.Count; Rectangle rectangle = new Rectangle(x, y, width, height); g2.DrawRectangle(Pens.Black, rectangle); SolidBrush semiTransBrush = new SolidBrush(Color.FromArgb(128, 150, 0, 0)); g2.FillRectangle(semiTransBrush, rectangle); g2.FillRectangle(Brushes.Violet, rectangle); } } public List&amp;lt;Intervalli&amp;gt; getDistribution(List&amp;lt;Strade&amp;gt; paths, int noIntervals, int j) { List&amp;lt;double&amp;gt; frequencies = new List&amp;lt;double&amp;gt;(); for (int i = 0; i &amp;lt; paths.Count; i&#43;&#43;) { for (int k = 0; k &amp;lt; paths[i].getPath().Count; k&#43;&#43;) { if (paths[i].getPath()[k].X == j) { frequencies.Add(paths[i].getPath()[k].Y); } } } List&amp;lt;Intervalli&amp;gt; intervals = new List&amp;lt;Intervalli&amp;gt;(); double intervalLength = 1.0 / (double)noIntervals; for (int i= -noIntervals; i &amp;lt; noIntervals; i&#43;&#43;) { intervals.Add(new Intervalli(i * intervalLength, (i &#43; 1) * intervalLength)); } for (int i = 0; i &amp;lt; intervals.Count; i&#43;&#43;) { for (int k = 0; k &amp;lt; frequencies.Count; k&#43;&#43;) { if ((frequencies[k] &amp;gt;= intervals[i].LowerBound) &amp;amp;&amp;amp; (frequencies[k] &amp;lt; intervals[i].UpperBound)) { intervals[i].Counter&#43;&#43;; } } } return intervals; } public List&amp;lt;Strade&amp;gt; fromPathstoViewport(List&amp;lt;Strade&amp;gt; paths, Rectangle viewPort) { List&amp;lt;Strade&amp;gt; viewPortPaths = new List&amp;lt;Strade&amp;gt;(); foreach (Strade path in paths) { PointF[] viewPortArrayPath = path.getPath().ToArray(); for (int i = 0;i &amp;lt; viewPortArrayPath.Length; i&#43;&#43;) { viewPortArrayPath[i].Y= (viewPortArrayPath[i].Y &#43; 1) / 2; } this.m1.TransformPoints(viewPortArrayPath); viewPortPaths.Add(new Strade(viewPortArrayPath.ToList())); } return viewPortPaths; } public Graphics getGrapichs() { return this.g2; } }  ]]></content:encoded>
    </item>
    <item>
      <title>9_R</title>
      <link>https://www.matteobianchi.eu/statistics-posts/week_7/9r/</link>
      <pubDate>Thu, 28 Oct 2021 18:03:36 UT</pubDate>
      <dc:creator>Matteo Bianchi</dc:creator>
      <guid>https://www.matteobianchi.eu/statistics-posts/week_7/9r/</guid>
      <description>9_R assignament Request History and derivation of the normal distribution. Touch, at least, the following three important perspectives, putting them into an historical context to understand how the idea developed:
 as approximation of binomial (De Moivre) as error curve (Gauss) as limit of sum of independent r.v.&amp;rsquo;s (Laplace)      The normal distribution as approximation of binomial Historically, being able to compute binomial probabilities was one of the most important applications of the central limit theorem.</description>
      <category domain="https://www.matteobianchi.eu/categories/statistic">Statistic</category>
      <content:encoded><![CDATA[9_R assignament Request History and derivation of the normal distribution. Touch, at least, the following three important perspectives, putting them into an historical context to understand how the idea developed:
 as approximation of binomial (De Moivre) as error curve (Gauss) as limit of sum of independent r.v.&amp;rsquo;s (Laplace)      The normal distribution as approximation of binomial Historically, being able to compute binomial probabilities was one of the most important applications of the central limit theorem. Binomial probabilities with a small value for n (say, 20) were displayed in a table in a book. To calculate the probabilities with large values of n , you had to use the binomial formula, which could be very complicated. Using the normal approximation to the binomial distribution simplified the process. To compute the normal approximation to the binomial distribution, take a simple random sample from a population. You must meet the conditions for a binomial distribution:
 there are a certain number n of independent trials the outcomes of any trial are success or failure each trial has the same probability of a success p Recall that if X is the binomial random variable, then X∼B(n,p) . The shape of the binomial distribution needs to be similar to the shape of the normal distribution. To ensure this, the quantities np and nq must both be greater than five ( np&amp;gt;5 and nq&amp;gt;5 ); the approximation is better if they are both greater than or equal to 10). Then the binomial can be approximated by the normal distribution with mean μ=np and standard deviation σ=√(npq) . Remember that q=1−p . In order to get the best approximation, add 0.5 to x or subtract 0.5 from x (use x&#43;0.5 or x−0.5 ). The number 0.5 is called the continuity correction factor[1]  As error Curve (Gauss) The normal distribution is also called Gaussian distribution in refers to Carl Friedrich Gauss, who first developed a two-parameter exponential function in 1809 in connection with studies of astronomical observation errors.This study led Gauss to formulate his law of observational error and to advance the theory of the method of least squares approximation.[4]
When we look at a standardized Gaussian distribution in the so-called Normal Error Curve you can see that the probability of any one measurement being a member of this particular distribution increases as the magnitude of z increases.[2]
as limit of sum of independent r.v.&amp;rsquo;s (Laplace) Laplace’s theorem states that if the error curve of a single observation is symmetric, then the error curve of the sum of several observations is indeed approximated by one of the Gaussian curves we have see before[3]. Hence if we take the further step of imagining that the error involved in an individual observation is the aggregate of a large number of “elementary” or “atomic” errors, then this theorem predicts that the random error that occurs in that individual observation is indeed controlled by De Moivre and Gauss’s curve, we call this the hypothesis of elementary errors
Beyond errors The first mathematician to extend the provenance of the normal distribution beyond the distribution of measurement errors was Adolphe Quetelet (1796–1874). He began his career as an astronomer but then moved on to the social sciences. Consequently, he possessed an unusual combination of qualifications that placed him in just the right position for him to be able to make one of the most influential scientific observations of all times. He made in fact an analysis on the chest size of the Scottish soliders
   Girth Frequency     33 3   34 18   35 81   36 185   37 420   38 749   39 1,073   40 1,079   41 934   42 658   43 370   44 92   45 50   46 21   47 4   48 1    and find out that the pattern followed by the variety of its chest measurements was identical with that formed by the type of repeated measurements that are common in astronomy. In modern terminology, Quetelet claimed that the chest measurements were normally distributed!
[1]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://stats.libretexts.org/Courses/Las_Positas_College/Math_40%3A_Statistics_and_Probability/06%3A_Continuous_Random_Variables_and_the_Normal_Distribution/6.04%3A_Normal_Approximatio### n_to_the_Binomial_Distribution&amp;rdquo; [2]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://chem.libretexts.org/Bookshelves/Analytical_Chemistry/Supplemental_Modules_(Analytical_Chemistry)/Analytical_Sciences_Digital_Library/JASDL/Courseware/Introduction_to_Signals_and_Noise/02_Signals_and_Noise/04_Normal_Error_Curve&amp;quot; [3]&amp;ldquo;url&amp;rdquo;,&amp;ldquo;https://www.maa.org/sites/default/files/pdf/upload_library/22/Allendoerfer/stahl96.pdf&amp;quot; [4]&amp;ldquo;From Abraham De Moivre to Johann Carl Friedrich Gauss&amp;rdquo;,&amp;ldquo;http://www.ijesi.org/papers/Vol(7)i6/Version-5/D0706052834.pdf&amp;quot;
]]></content:encoded>
    </item>
  </channel>
</rss>
